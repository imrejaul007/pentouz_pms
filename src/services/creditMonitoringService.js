import CorporateCompany from '../models/CorporateCompany.js';
import CorporateCredit from '../models/CorporateCredit.js';
import StaffAlert from '../models/StaffAlert.js';
import User from '../models/User.js';
import creditSecurityService from './creditSecurityService.js';
import mongoose from 'mongoose';

/**
 * Credit Monitoring Service
 * Handles automated credit monitoring, alerts, and risk assessment
 */
class CreditMonitoringService {

  /**
   * Monitor all corporate companies for credit issues
   * @param {string} hotelId - Hotel ID to monitor
   * @returns {Object} Monitoring results
   */
  async monitorCreditStatus(hotelId) {
    try {
      const companies = await CorporateCompany.find({
        hotelId,
        isActive: true
      });

      const results = {
        totalCompanies: companies.length,
        lowCreditAlerts: [],
        overLimitCompanies: [],
        highUtilizationCompanies: [],
        inactiveCompanies: [],
        alertsCreated: 0
      };

      for (const company of companies) {
        await this.assessCompanyCreditRisk(company, results);
      }

      // Create staff alerts for critical issues
      if (results.lowCreditAlerts.length > 0 || results.overLimitCompanies.length > 0) {
        await this.createStaffAlerts(hotelId, results);
      }

      return results;
    } catch (error) {
      console.error('Credit monitoring error:', error);
      throw error;
    }
  }

  /**
   * Assess individual company credit risk
   * @param {Object} company - Company document
   * @param {Object} results - Results object to populate
   */
  async assessCompanyCreditRisk(company, results) {
    const utilizationRate = company.creditLimit > 0
      ? ((company.creditLimit - company.availableCredit) / company.creditLimit) * 100
      : 0;

    // Check for low available credit (less than 20% of limit)
    if (company.creditLimit > 0 && (company.availableCredit / company.creditLimit) < 0.2) {
      results.lowCreditAlerts.push({
        companyId: company._id,
        companyName: company.name,
        availableCredit: company.availableCredit,
        creditLimit: company.creditLimit,
        utilizationRate: utilizationRate.toFixed(2),
        severity: 'medium'
      });
    }

    // Check for over-limit situations (negative available credit)
    if (company.availableCredit < 0) {
      results.overLimitCompanies.push({
        companyId: company._id,
        companyName: company.name,
        availableCredit: company.availableCredit,
        creditLimit: company.creditLimit,
        overLimitAmount: Math.abs(company.availableCredit),
        severity: 'high'
      });
    }

    // Check for high utilization (over 75%)
    if (utilizationRate > 75) {
      results.highUtilizationCompanies.push({
        companyId: company._id,
        companyName: company.name,
        utilizationRate: utilizationRate.toFixed(2),
        availableCredit: company.availableCredit,
        creditLimit: company.creditLimit,
        severity: utilizationRate > 90 ? 'high' : 'medium'
      });
    }
  }

  /**
   * Create staff alerts for credit issues
   * @param {string} hotelId - Hotel ID
   * @param {Object} results - Monitoring results
   */
  async createStaffAlerts(hotelId, results) {
    try {
      const adminUsers = await User.find({
        hotelId,
        role: { $in: ['admin', 'manager'] },
        isActive: true
      });

      const alerts = [];

      // Create alerts for low credit companies
      for (const alert of results.lowCreditAlerts) {
        alerts.push({
          hotelId,
          type: 'credit_warning',
          priority: alert.severity === 'high' ? 'high' : 'medium',
          title: `Low Credit Alert: ${alert.companyName}`,
          message: `Company has only ₹${alert.availableCredit.toLocaleString()} available credit remaining (${(100 - parseFloat(alert.utilizationRate)).toFixed(1)}% of limit). Current utilization: ${alert.utilizationRate}%`,
          data: {
            companyId: alert.companyId,
            companyName: alert.companyName,
            availableCredit: alert.availableCredit,
            creditLimit: alert.creditLimit,
            utilizationRate: alert.utilizationRate,
            alertType: 'low_credit'
          },
          assignedTo: adminUsers.map(user => user._id),
          metadata: {
            createdBy: 'system',
            source: 'credit_monitoring',
            autoGenerated: true
          }
        });
      }

      // Create alerts for over-limit companies
      for (const alert of results.overLimitCompanies) {
        alerts.push({
          hotelId,
          type: 'credit_critical',
          priority: 'critical',
          title: `CRITICAL: ${alert.companyName} Over Credit Limit`,
          message: `Company has exceeded their credit limit by ₹${alert.overLimitAmount.toLocaleString()}. Immediate action required to prevent further credit extension.`,
          data: {
            companyId: alert.companyId,
            companyName: alert.companyName,
            availableCredit: alert.availableCredit,
            creditLimit: alert.creditLimit,
            overLimitAmount: alert.overLimitAmount,
            alertType: 'over_limit'
          },
          assignedTo: adminUsers.map(user => user._id),
          requiresAction: true,
          metadata: {
            createdBy: 'system',
            source: 'credit_monitoring',
            autoGenerated: true
          }
        });
      }

      // Bulk create alerts, avoiding duplicates
      if (alerts.length > 0) {
        const existingAlerts = await StaffAlert.find({
          hotelId,
          type: { $in: ['credit_warning', 'credit_critical'] },
          status: { $in: ['pending', 'acknowledged'] },
          createdAt: { $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) } // Last 24 hours
        });

        const existingCompanyIds = new Set(
          existingAlerts.map(alert => alert.data?.companyId?.toString()).filter(Boolean)
        );

        const newAlerts = alerts.filter(alert =>
          !existingCompanyIds.has(alert.data.companyId.toString())
        );

        if (newAlerts.length > 0) {
          await StaffAlert.insertMany(newAlerts);
          results.alertsCreated = newAlerts.length;
        }
      }

    } catch (error) {
      console.error('Error creating staff alerts:', error);
    }
  }

  /**
   * Check if a booking can be made based on available credit
   * @param {string} companyId - Company ID
   * @param {number} bookingAmount - Booking amount to validate
   * @returns {Object} Validation result
   */
  async validateBookingCredit(companyId, bookingAmount) {
    try {
      const company = await CorporateCompany.findById(companyId);

      if (!company) {
        return {
          isValid: false,
          reason: 'Company not found',
          availableCredit: 0,
          requiredAmount: bookingAmount
        };
      }

      if (!company.isActive) {
        return {
          isValid: false,
          reason: 'Company account is inactive',
          availableCredit: company.availableCredit,
          requiredAmount: bookingAmount
        };
      }

      const isValid = company.availableCredit >= bookingAmount;
      const newBalance = company.availableCredit - bookingAmount;
      const utilizationAfter = company.creditLimit > 0
        ? ((company.creditLimit - newBalance) / company.creditLimit) * 100
        : 0;

      return {
        isValid,
        reason: isValid ? null : 'Insufficient available credit',
        availableCredit: company.availableCredit,
        requiredAmount: bookingAmount,
        balanceAfter: newBalance,
        utilizationAfter: utilizationAfter.toFixed(2),
        warningLevel: utilizationAfter > 80 ? 'high' : utilizationAfter > 60 ? 'medium' : 'low'
      };

    } catch (error) {
      console.error('Credit validation error:', error);
      return {
        isValid: false,
        reason: 'Validation error occurred',
        error: error.message
      };
    }
  }

  /**
   * Process a booking credit transaction
   * @param {string} companyId - Company ID
   * @param {number} amount - Transaction amount
   * @param {string} bookingId - Booking ID
   * @param {string} userId - User ID who created the booking
   * @returns {Object} Transaction result
   */
  async processBookingCredit(companyId, amount, bookingId, userId, auditContext = {}) {
    try {
      console.log('Starting processBookingCredit with params:', { companyId, amount, bookingId, userId });

      // Security validation first
      const inputValidation = creditSecurityService.validateCreditInput({
        companyId,
        amount,
        bookingId
      }, 'bookingCredit');

      if (!inputValidation.isValid) {
        await creditSecurityService.logCreditOperation({
          operation: 'BOOKING_CREDIT_FAILED',
          userId,
          companyId,
          details: {
            reason: 'Invalid input',
            errors: inputValidation.errors,
            originalAmount: amount,
            originalBookingId: bookingId
          },
          severity: 'warning',
          success: false,
          error: inputValidation.errors.join(', '),
          ...auditContext
        });

        return {
          success: false,
          reason: 'Invalid input data',
          errors: inputValidation.errors
        };
      }

      // Use sanitized data
      const { companyId: safeCompanyId, amount: safeAmount, bookingId: safeBookingId } = inputValidation.sanitizedData;

      // Validate credit first
      const validation = await this.validateBookingCredit(safeCompanyId, safeAmount);
      console.log('Credit validation result:', validation);

      if (!validation.isValid) {
        await creditSecurityService.logCreditOperation({
          operation: 'BOOKING_CREDIT_REJECTED',
          userId,
          companyId: safeCompanyId,
          details: {
            reason: validation.reason,
            amount: safeAmount,
            bookingId: safeBookingId,
            availableCredit: validation.availableCredit
          },
          severity: 'info',
          success: false,
          ...auditContext
        });

        return {
          success: false,
          reason: validation.reason,
          validation
        };
      }

      // Update company available credit
      const company = await CorporateCompany.findById(companyId);
      if (!company) {
        return {
          success: false,
          reason: 'Company not found during processing'
        };
      }

      console.log('Company found:', { id: company._id, name: company.name, availableCredit: company.availableCredit });

      company.availableCredit -= amount;
      await company.save();
      console.log('Company credit updated, new balance:', company.availableCredit);

      // Create credit transaction with exact pattern from working test
      const transactionData = {
        hotelId: company.hotelId,
        corporateCompanyId: companyId,
        transactionType: 'debit',
        amount: amount,
        balance: company.availableCredit,
        description: `Booking credit deduction - Booking ID: ${bookingId}`,
        status: 'processed',
        category: 'accommodation',
        reference: bookingId,
        metadata: {
          createdBy: userId,
          source: 'booking'
        }
      };

      console.log('Creating credit transaction with data:', transactionData);

      const creditTransaction = await CorporateCredit.create(transactionData);
      console.log('Credit transaction created successfully:', creditTransaction._id);

      // Check if we need to create alerts after this transaction
      const utilizationRate = company.creditLimit > 0
        ? ((company.creditLimit - company.availableCredit) / company.creditLimit) * 100
        : 0;

      let alertCreated = false;
      if (utilizationRate > 80) {
        await this.monitorCreditStatus(company.hotelId);
        alertCreated = true;
      }

      return {
        success: true,
        transaction: creditTransaction,
        companyBalance: company.availableCredit,
        utilizationRate: utilizationRate.toFixed(2),
        alertCreated
      };

    } catch (error) {
      console.error('Credit processing error:', error);
      console.error('Error details:', {
        companyId,
        amount,
        bookingId,
        userId,
        stack: error.stack
      });
      return {
        success: false,
        reason: 'Processing error occurred',
        error: error.message,
        details: error.stack
      };
    }
  }

  /**
   * Handle credit limit increase requests with approval workflow
   * @param {string} companyId - Company ID
   * @param {number} requestedLimit - Requested new credit limit
   * @param {string} requestedBy - User ID requesting the increase
   * @param {string} justification - Business justification
   * @returns {Object} Request result
   */
  async requestCreditLimitIncrease(companyId, requestedLimit, requestedBy, justification, auditContext = {}) {
    try {
      // Security validation first
      const inputValidation = creditSecurityService.validateCreditInput({
        companyId, requestedLimit, justification
      }, 'creditLimitRequest');

      if (!inputValidation.isValid) {
        await creditSecurityService.logCreditOperation({
          operation: 'CREDIT_LIMIT_REQUEST_FAILED',
          userId: requestedBy,
          companyId,
          details: {
            reason: 'Invalid input',
            errors: inputValidation.errors,
            requestedLimit
          },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'warning',
          success: false
        });
        return { success: false, reason: 'Invalid input data', errors: inputValidation.errors };
      }

      const sanitizedData = inputValidation.sanitizedData;
      const company = await CorporateCompany.findById(sanitizedData.companyId);
      if (!company) {
        await creditSecurityService.logCreditOperation({
          operation: 'CREDIT_LIMIT_REQUEST_FAILED',
          userId: requestedBy,
          companyId: sanitizedData.companyId,
          details: { reason: 'Company not found' },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'warning',
          success: false
        });
        return { success: false, reason: 'Company not found' };
      }

      // Validate credit limit change for suspicious patterns
      const limitValidation = await creditSecurityService.validateCreditLimitChange(
        sanitizedData.companyId,
        company.creditLimit,
        sanitizedData.requestedLimit,
        requestedBy
      );

      if (!limitValidation.isValid && limitValidation.riskLevel === 'high') {
        await creditSecurityService.logCreditOperation({
          operation: 'CREDIT_LIMIT_REQUEST_SUSPICIOUS',
          userId: requestedBy,
          companyId: sanitizedData.companyId,
          hotelId: company.hotelId,
          details: {
            suspiciousPatterns: limitValidation.suspiciousPatterns,
            currentLimit: company.creditLimit,
            requestedLimit: sanitizedData.requestedLimit
          },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'high',
          success: false
        });
        return {
          success: false,
          reason: 'Credit limit change flagged for review',
          riskLevel: limitValidation.riskLevel,
          patterns: limitValidation.suspiciousPatterns
        };
      }

      // Check if there's already a pending request
      const existingRequest = await StaffAlert.findOne({
        'data.companyId': sanitizedData.companyId,
        type: 'credit_limit_request',
        status: { $in: ['pending', 'acknowledged'] }
      });

      if (existingRequest) {
        return { success: false, reason: 'Credit limit request already pending' };
      }

      // Get admin users for approval
      const adminUsers = await User.find({
        hotelId: company.hotelId,
        role: { $in: ['admin', 'manager'] },
        isActive: true
      });

      // Create approval request alert
      const requestAlert = await StaffAlert.create({
        hotelId: company.hotelId,
        type: 'credit_limit_request',
        priority: 'high',
        title: `Credit Limit Increase Request: ${company.name}`,
        message: `Request to increase credit limit from ₹${company.creditLimit.toLocaleString()} to ₹${sanitizedData.requestedLimit.toLocaleString()}. Current available: ₹${company.availableCredit.toLocaleString()}. Justification: ${sanitizedData.justification}`,
        data: {
          companyId: company._id,
          companyName: company.name,
          currentLimit: company.creditLimit,
          requestedLimit: sanitizedData.requestedLimit,
          availableCredit: company.availableCredit,
          requestedBy,
          justification: sanitizedData.justification,
          requestType: 'credit_limit_increase'
        },
        assignedTo: adminUsers.map(user => user._id),
        requiresAction: true,
        metadata: {
          createdBy: requestedBy,
          source: 'credit_management',
          autoGenerated: false
        }
      });

      // Log successful request
      await creditSecurityService.logCreditOperation({
        operation: 'CREDIT_LIMIT_REQUEST_CREATED',
        userId: requestedBy,
        companyId: sanitizedData.companyId,
        hotelId: company.hotelId,
        details: {
          requestId: requestAlert._id,
          currentLimit: company.creditLimit,
          requestedLimit: sanitizedData.requestedLimit,
          justification: sanitizedData.justification
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: 'info',
        success: true
      });

      return {
        success: true,
        requestId: requestAlert._id,
        message: 'Credit limit increase request submitted for approval',
        pendingApproval: true
      };

    } catch (error) {
      console.error('Credit limit request error:', error);
      return {
        success: false,
        reason: 'Failed to submit request',
        error: error.message
      };
    }
  }

  /**
   * Approve or reject credit limit increase request
   * @param {string} requestId - Staff alert ID for the request
   * @param {string} action - 'approve' or 'reject'
   * @param {string} approvedBy - User ID approving/rejecting
   * @param {string} comments - Approval/rejection comments
   * @returns {Object} Approval result
   */
  async processCreditLimitRequest(requestId, action, approvedBy, comments) {
    try {
      const request = await StaffAlert.findById(requestId);
      if (!request || request.type !== 'credit_limit_request') {
        return { success: false, reason: 'Request not found' };
      }

      if (request.status === 'resolved') {
        return { success: false, reason: 'Request already processed' };
      }

      const company = await CorporateCompany.findById(request.data.companyId);
      if (!company) {
        return { success: false, reason: 'Company not found' };
      }

      let result = { success: true };

      if (action === 'approve') {
        // Update company credit limit
        const oldLimit = company.creditLimit;
        const newLimit = request.data.requestedLimit;
        const creditIncrease = newLimit - oldLimit;

        company.creditLimit = newLimit;
        company.availableCredit += creditIncrease;
        await company.save();

        // Create credit adjustment transaction
        await CorporateCredit.create({
          hotelId: company.hotelId,
          corporateCompanyId: company._id,
          transactionType: 'credit',
          amount: creditIncrease,
          balance: company.availableCredit,
          description: `Credit limit increase approved - From ₹${oldLimit.toLocaleString()} to ₹${newLimit.toLocaleString()}`,
          status: 'processed',
          category: 'adjustment',
          reference: `LIMIT_INCREASE_${requestId}`,
          metadata: {
            createdBy: approvedBy,
            source: 'credit_approval',
            requestId
          }
        });

        result.message = `Credit limit increased from ₹${oldLimit.toLocaleString()} to ₹${newLimit.toLocaleString()}`;
        result.newLimit = newLimit;
        result.newAvailableCredit = company.availableCredit;

      } else if (action === 'reject') {
        result.message = 'Credit limit increase request rejected';
      }

      // Update the request status
      request.status = 'resolved';
      request.resolvedAt = new Date();
      request.resolvedBy = approvedBy;
      request.resolution = {
        action,
        comments,
        processedAt: new Date()
      };
      await request.save();

      // Send notification to requestor
      const requestor = await User.findById(request.data.requestedBy);
      if (requestor) {
        await StaffAlert.create({
          hotelId: company.hotelId,
          type: 'credit_request_response',
          priority: 'medium',
          title: `Credit Request ${action === 'approve' ? 'Approved' : 'Rejected'}: ${company.name}`,
          message: `Your credit limit request has been ${action === 'approve' ? 'approved' : 'rejected'}. ${comments || ''}`,
          data: {
            originalRequestId: requestId,
            companyId: company._id,
            companyName: company.name,
            action,
            comments
          },
          assignedTo: [requestor._id],
          metadata: {
            createdBy: approvedBy,
            source: 'credit_approval',
            autoGenerated: true
          }
        });
      }

      return result;

    } catch (error) {
      console.error('Credit limit approval error:', error);
      return {
        success: false,
        reason: 'Failed to process request',
        error: error.message
      };
    }
  }

  /**
   * Process credit adjustments (manual corrections)
   * @param {string} companyId - Company ID
   * @param {number} adjustmentAmount - Amount to adjust (positive or negative)
   * @param {string} reason - Reason for adjustment
   * @param {string} adjustedBy - User ID making adjustment
   * @returns {Object} Adjustment result
   */
  async processCreditAdjustment(companyId, adjustmentAmount, reason, adjustedBy, auditContext = {}) {
    try {
      // Security validation first
      const inputValidation = creditSecurityService.validateCreditInput({
        companyId, adjustmentAmount, reason
      }, 'creditAdjustment');

      if (!inputValidation.isValid) {
        await creditSecurityService.logCreditOperation({
          operation: 'CREDIT_ADJUSTMENT_FAILED',
          userId: adjustedBy,
          companyId,
          details: {
            reason: 'Invalid input',
            errors: inputValidation.errors,
            adjustmentAmount
          },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'warning',
          success: false
        });
        return { success: false, reason: 'Invalid input data', errors: inputValidation.errors };
      }

      const sanitizedData = inputValidation.sanitizedData;
      const company = await CorporateCompany.findById(sanitizedData.companyId);
      if (!company) {
        await creditSecurityService.logCreditOperation({
          operation: 'CREDIT_ADJUSTMENT_FAILED',
          userId: adjustedBy,
          companyId: sanitizedData.companyId,
          details: { reason: 'Company not found' },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'warning',
          success: false
        });
        return { success: false, reason: 'Company not found' };
      }

      const oldBalance = company.availableCredit;
      const newBalance = oldBalance + sanitizedData.adjustmentAmount;

      if (newBalance < 0 && sanitizedData.adjustmentAmount < 0) {
        return {
          success: false,
          reason: 'Adjustment would result in negative available credit',
          currentBalance: oldBalance,
          adjustmentAmount: sanitizedData.adjustmentAmount,
          wouldResultIn: newBalance
        };
      }

      // Update company available credit
      company.availableCredit = newBalance;
      await company.save();

      // Create adjustment transaction
      const transaction = await CorporateCredit.create({
        hotelId: company.hotelId,
        corporateCompanyId: sanitizedData.companyId,
        transactionType: sanitizedData.adjustmentAmount > 0 ? 'credit' : 'adjustment',
        amount: Math.abs(sanitizedData.adjustmentAmount),
        balance: newBalance,
        description: `Manual credit adjustment: ${sanitizedData.reason}`,
        status: 'processed',
        category: 'adjustment',
        reference: `ADJ_${Date.now()}`,
        metadata: {
          createdBy: adjustedBy,
          source: 'manual_adjustment',
          adjustmentType: sanitizedData.adjustmentAmount > 0 ? 'increase' : 'decrease'
        }
      });

      // Create audit alert for significant adjustments
      if (Math.abs(sanitizedData.adjustmentAmount) > 10000) {
        const adminUsers = await User.find({
          hotelId: company.hotelId,
          role: { $in: ['admin', 'manager'] },
          isActive: true
        });

        await StaffAlert.create({
          hotelId: company.hotelId,
          type: 'credit_adjustment_audit',
          priority: 'medium',
          title: `Large Credit Adjustment: ${company.name}`,
          message: `Credit adjustment of ₹${sanitizedData.adjustmentAmount.toLocaleString()} made. Old balance: ₹${oldBalance.toLocaleString()}, New balance: ₹${newBalance.toLocaleString()}. Reason: ${sanitizedData.reason}`,
          data: {
            companyId: sanitizedData.companyId,
            companyName: company.name,
            adjustmentAmount: sanitizedData.adjustmentAmount,
            oldBalance,
            newBalance,
            reason: sanitizedData.reason,
            transactionId: transaction._id
          },
          assignedTo: adminUsers.map(user => user._id),
          metadata: {
            createdBy: adjustedBy,
            source: 'credit_adjustment',
            autoGenerated: true
          }
        });
      }

      // Log successful adjustment
      await creditSecurityService.logCreditOperation({
        operation: 'CREDIT_ADJUSTMENT_PROCESSED',
        userId: adjustedBy,
        companyId: sanitizedData.companyId,
        hotelId: company.hotelId,
        details: {
          transactionId: transaction._id,
          adjustmentAmount: sanitizedData.adjustmentAmount,
          oldBalance,
          newBalance,
          reason: sanitizedData.reason
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: Math.abs(sanitizedData.adjustmentAmount) > 50000 ? 'critical' : 'info',
        success: true
      });

      return {
        success: true,
        transaction: transaction,
        oldBalance,
        newBalance,
        adjustmentAmount,
        message: `Credit adjusted by ₹${adjustmentAmount.toLocaleString()}. New balance: ₹${newBalance.toLocaleString()}`
      };

    } catch (error) {
      console.error('Credit adjustment error:', error);
      return {
        success: false,
        reason: 'Failed to process adjustment',
        error: error.message
      };
    }
  }

  /**
   * Get pending credit requests for approval
   * @param {string} hotelId - Hotel ID
   * @returns {Object} Pending requests
   */
  async getPendingCreditRequests(hotelId) {
    try {
      const pendingRequests = await StaffAlert.find({
        hotelId,
        type: { $in: ['credit_limit_request', 'credit_adjustment_request'] },
        status: { $in: ['pending', 'acknowledged'] }
      }).populate('data.requestedBy', 'name email').sort({ createdAt: -1 });

      return {
        success: true,
        requests: pendingRequests,
        count: pendingRequests.length
      };

    } catch (error) {
      console.error('Error getting pending requests:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Enhanced notification system for low credit alerts
   * @param {string} hotelId - Hotel ID
   * @param {Object} notificationConfig - Notification configuration
   * @returns {Object} Notification result
   */
  async sendLowCreditNotifications(hotelId, notificationConfig = {}) {
    try {
      const {
        lowCreditThreshold = 20, // Default: Alert when below 20%
        criticalThreshold = 10,  // Default: Critical when below 10%
        emailNotifications = true,
        smsNotifications = false,
        slackNotifications = false,
        webhookNotifications = false
      } = notificationConfig;

      const companies = await CorporateCompany.find({
        hotelId,
        isActive: true,
        creditLimit: { $gt: 0 }
      });

      const notifications = {
        emailsSent: 0,
        alertsCreated: 0,
        companiesNotified: [],
        criticalAlerts: [],
        warnings: []
      };

      for (const company of companies) {
        const availablePercentage = (company.availableCredit / company.creditLimit) * 100;
        const utilizationRate = 100 - availablePercentage;

        let alertLevel = null;
        let priority = 'low';

        if (availablePercentage <= criticalThreshold) {
          alertLevel = 'critical';
          priority = 'critical';
          notifications.criticalAlerts.push({
            companyId: company._id,
            companyName: company.name,
            availableCredit: company.availableCredit,
            creditLimit: company.creditLimit,
            availablePercentage: availablePercentage.toFixed(1),
            utilizationRate: utilizationRate.toFixed(1)
          });
        } else if (availablePercentage <= lowCreditThreshold) {
          alertLevel = 'warning';
          priority = 'medium';
          notifications.warnings.push({
            companyId: company._id,
            companyName: company.name,
            availableCredit: company.availableCredit,
            creditLimit: company.creditLimit,
            availablePercentage: availablePercentage.toFixed(1),
            utilizationRate: utilizationRate.toFixed(1)
          });
        }

        if (alertLevel) {
          // Get notification recipients
          const recipients = await User.find({
            hotelId,
            role: { $in: ['admin', 'manager', 'staff'] },
            isActive: true,
            'notificationPreferences.creditAlerts': { $ne: false }
          });

          // Create staff alert
          await StaffAlert.create({
            hotelId,
            type: `credit_${alertLevel}`,
            priority,
            title: `${alertLevel === 'critical' ? 'CRITICAL' : 'WARNING'}: Low Credit - ${company.name}`,
            message: `${company.name} has only ₹${company.availableCredit.toLocaleString()} available credit remaining (${availablePercentage.toFixed(1)}% of ₹${company.creditLimit.toLocaleString()} limit). Utilization: ${utilizationRate.toFixed(1)}%`,
            data: {
              companyId: company._id,
              companyName: company.name,
              availableCredit: company.availableCredit,
              creditLimit: company.creditLimit,
              availablePercentage: parseFloat(availablePercentage.toFixed(1)),
              utilizationRate: parseFloat(utilizationRate.toFixed(1)),
              alertLevel,
              threshold: alertLevel === 'critical' ? criticalThreshold : lowCreditThreshold
            },
            assignedTo: recipients.map(user => user._id),
            requiresAction: alertLevel === 'critical',
            metadata: {
              createdBy: 'system',
              source: 'low_credit_monitoring',
              autoGenerated: true,
              notificationConfig
            }
          });

          notifications.alertsCreated++;
          notifications.companiesNotified.push({
            companyId: company._id,
            companyName: company.name,
            alertLevel,
            recipientCount: recipients.length
          });

          // Send email notifications if enabled
          if (emailNotifications && recipients.length > 0) {
            try {
              // This would integrate with your email service
              const emailData = {
                to: recipients.map(user => user.email),
                subject: `${alertLevel === 'critical' ? '🚨 CRITICAL' : '⚠️ WARNING'}: Low Credit Alert - ${company.name}`,
                template: 'low-credit-alert',
                data: {
                  companyName: company.name,
                  availableCredit: company.availableCredit.toLocaleString(),
                  creditLimit: company.creditLimit.toLocaleString(),
                  availablePercentage: availablePercentage.toFixed(1),
                  utilizationRate: utilizationRate.toFixed(1),
                  alertLevel,
                  dashboardUrl: process.env.FRONTEND_URL + '/admin/corporate/companies/' + company._id
                }
              };

              console.log('Email notification prepared:', emailData);
              notifications.emailsSent += recipients.length;

            } catch (emailError) {
              console.error('Email notification error:', emailError);
            }
          }

          // Additional notification channels can be added here
          if (smsNotifications) {
            // SMS integration
            console.log('SMS notification would be sent for:', company.name);
          }

          if (slackNotifications) {
            // Slack integration
            console.log('Slack notification would be sent for:', company.name);
          }

          if (webhookNotifications) {
            // Webhook integration
            console.log('Webhook notification would be sent for:', company.name);
          }
        }
      }

      return {
        success: true,
        notifications,
        summary: {
          totalCompanies: companies.length,
          companiesWithAlerts: notifications.companiesNotified.length,
          criticalAlerts: notifications.criticalAlerts.length,
          warnings: notifications.warnings.length,
          alertsCreated: notifications.alertsCreated,
          emailsSent: notifications.emailsSent
        }
      };

    } catch (error) {
      console.error('Low credit notification error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Schedule automated credit monitoring with configurable frequency
   * @param {string} hotelId - Hotel ID
   * @param {Object} scheduleConfig - Schedule configuration
   * @returns {Object} Schedule result
   */
  async scheduleAutomatedMonitoring(hotelId, scheduleConfig = {}) {
    try {
      const {
        frequency = 'daily', // hourly, daily, weekly
        time = '09:00',      // Time to run (24h format)
        enabled = true,
        notificationConfig = {}
      } = scheduleConfig;

      // Store monitoring configuration (this could be in a separate ScheduledTasks collection)
      const monitoringSchedule = {
        hotelId,
        type: 'credit_monitoring',
        frequency,
        time,
        enabled,
        configuration: {
          ...notificationConfig,
          lastRun: null,
          nextRun: this.calculateNextRun(frequency, time),
          failures: 0,
          maxFailures: 3
        },
        createdAt: new Date(),
        updatedAt: new Date()
      };

      console.log('Monitoring schedule configured:', monitoringSchedule);

      return {
        success: true,
        schedule: monitoringSchedule,
        message: `Automated credit monitoring scheduled to run ${frequency} at ${time}`
      };

    } catch (error) {
      console.error('Schedule monitoring error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Calculate next run time based on frequency
   * @private
   */
  calculateNextRun(frequency, time) {
    const now = new Date();
    const [hours, minutes] = time.split(':').map(Number);
    const nextRun = new Date(now);

    nextRun.setHours(hours, minutes, 0, 0);

    if (nextRun <= now) {
      switch (frequency) {
        case 'hourly':
          nextRun.setHours(nextRun.getHours() + 1);
          break;
        case 'daily':
          nextRun.setDate(nextRun.getDate() + 1);
          break;
        case 'weekly':
          nextRun.setDate(nextRun.getDate() + 7);
          break;
      }
    }

    return nextRun;
  }

  /**
   * Get detailed credit alert history
   * @param {string} hotelId - Hotel ID
   * @param {Object} filters - Filter options
   * @returns {Object} Alert history
   */
  async getCreditAlertHistory(hotelId, filters = {}) {
    try {
      const {
        companyId,
        alertLevel, // critical, warning
        startDate,
        endDate,
        limit = 50,
        offset = 0
      } = filters;

      const query = {
        hotelId,
        type: { $in: ['credit_critical', 'credit_warning'] }
      };

      if (companyId) {
        query['data.companyId'] = companyId;
      }

      if (alertLevel) {
        query.type = `credit_${alertLevel}`;
      }

      if (startDate || endDate) {
        query.createdAt = {};
        if (startDate) query.createdAt.$gte = new Date(startDate);
        if (endDate) query.createdAt.$lte = new Date(endDate);
      }

      const [alerts, totalCount] = await Promise.all([
        StaffAlert.find(query)
          .populate('data.companyId', 'name')
          .sort({ createdAt: -1 })
          .limit(limit)
          .skip(offset),
        StaffAlert.countDocuments(query)
      ]);

      return {
        success: true,
        alerts,
        pagination: {
          totalCount,
          limit,
          offset,
          hasMore: totalCount > (offset + limit)
        }
      };

    } catch (error) {
      console.error('Credit alert history error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get detailed transaction history timeline for a company
   * @param {string} companyId - Company ID
   * @param {Object} filters - Filter options
   * @returns {Object} Transaction timeline
   */
  async getTransactionHistoryTimeline(companyId, filters = {}) {
    try {
      const {
        startDate,
        endDate,
        transactionTypes, // ['debit', 'credit', 'adjustment', 'refund']
        limit = 50,
        offset = 0,
        includeBalanceHistory = true,
        groupByPeriod = null // 'day', 'week', 'month'
      } = filters;

      // Build query
      const query = {
        corporateCompanyId: companyId,
        status: 'processed'
      };

      if (startDate || endDate) {
        query.transactionDate = {};
        if (startDate) query.transactionDate.$gte = new Date(startDate);
        if (endDate) query.transactionDate.$lte = new Date(endDate);
      }

      if (transactionTypes && transactionTypes.length > 0) {
        query.transactionType = { $in: transactionTypes };
      }

      // Get transactions with related data
      const [transactions, totalCount, company] = await Promise.all([
        CorporateCredit.find(query)
          .populate('metadata.createdBy', 'name email')
          .populate('bookingId', 'bookingNumber guestName')
          .sort({ transactionDate: -1 })
          .limit(limit)
          .skip(offset),
        CorporateCredit.countDocuments(query),
        CorporateCompany.findById(companyId)
      ]);

      if (!company) {
        return { success: false, reason: 'Company not found' };
      }

      // Build timeline entries
      const timeline = transactions.map(transaction => {
        const entry = {
          id: transaction._id,
          timestamp: transaction.transactionDate,
          type: transaction.transactionType,
          amount: transaction.amount,
          balance: transaction.balance,
          description: transaction.description,
          reference: transaction.reference,
          category: transaction.category,
          status: transaction.status,
          metadata: {
            createdBy: transaction.metadata?.createdBy,
            source: transaction.metadata?.source,
            autoGenerated: transaction.metadata?.autoGenerated || false
          }
        };

        // Add type-specific information
        switch (transaction.transactionType) {
          case 'debit':
            entry.displayType = 'Booking Charge';
            entry.icon = 'receipt';
            entry.color = 'red';
            entry.balanceChange = -transaction.amount;
            if (transaction.bookingId) {
              entry.booking = {
                id: transaction.bookingId._id,
                number: transaction.bookingId.bookingNumber,
                guest: transaction.bookingId.guestName
              };
            }
            break;

          case 'credit':
            entry.displayType = 'Credit Added';
            entry.icon = 'plus-circle';
            entry.color = 'green';
            entry.balanceChange = transaction.amount;
            break;

          case 'adjustment':
            entry.displayType = 'Manual Adjustment';
            entry.icon = 'edit';
            entry.color = 'blue';
            entry.balanceChange = transaction.transactionType === 'credit' ? transaction.amount : -transaction.amount;
            break;

          case 'refund':
            entry.displayType = 'Refund';
            entry.icon = 'undo';
            entry.color = 'orange';
            entry.balanceChange = transaction.amount;
            break;

          default:
            entry.displayType = 'Transaction';
            entry.icon = 'activity';
            entry.color = 'gray';
            entry.balanceChange = 0;
        }

        // Calculate utilization at this point
        if (company.creditLimit > 0) {
          entry.utilizationRate = ((company.creditLimit - transaction.balance) / company.creditLimit * 100).toFixed(1);
        }

        return entry;
      });

      // Generate balance history if requested
      let balanceHistory = null;
      if (includeBalanceHistory && transactions.length > 0) {
        balanceHistory = {
          startingBalance: transactions[transactions.length - 1].balance +
            (transactions[transactions.length - 1].transactionType === 'debit' ? transactions[transactions.length - 1].amount : -transactions[transactions.length - 1].amount),
          endingBalance: transactions[0].balance,
          points: timeline.reverse().map(entry => ({
            timestamp: entry.timestamp,
            balance: entry.balance,
            change: entry.balanceChange
          })).reverse()
        };
      }

      // Group by period if requested
      let groupedTimeline = null;
      if (groupByPeriod && transactions.length > 0) {
        groupedTimeline = this.groupTransactionsByPeriod(timeline, groupByPeriod);
      }

      return {
        success: true,
        timeline,
        balanceHistory,
        groupedTimeline,
        company: {
          id: company._id,
          name: company.name,
          currentBalance: company.availableCredit,
          creditLimit: company.creditLimit,
          currentUtilization: company.creditLimit > 0 ? ((company.creditLimit - company.availableCredit) / company.creditLimit * 100).toFixed(1) : 0
        },
        pagination: {
          totalCount,
          limit,
          offset,
          hasMore: totalCount > (offset + limit)
        },
        summary: {
          totalTransactions: totalCount,
          dateRange: {
            earliest: transactions.length > 0 ? transactions[transactions.length - 1].transactionDate : null,
            latest: transactions.length > 0 ? transactions[0].transactionDate : null
          }
        }
      };

    } catch (error) {
      console.error('Transaction timeline error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Group transactions by time period
   * @private
   */
  groupTransactionsByPeriod(timeline, period) {
    const groups = {};

    timeline.forEach(transaction => {
      const date = new Date(transaction.timestamp);
      let groupKey;

      switch (period) {
        case 'day':
          groupKey = date.toISOString().split('T')[0];
          break;
        case 'week':
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay());
          groupKey = weekStart.toISOString().split('T')[0];
          break;
        case 'month':
          groupKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
          break;
        default:
          groupKey = date.toISOString().split('T')[0];
      }

      if (!groups[groupKey]) {
        groups[groupKey] = {
          period: groupKey,
          transactions: [],
          totalDebits: 0,
          totalCredits: 0,
          netAmount: 0,
          transactionCount: 0
        };
      }

      groups[groupKey].transactions.push(transaction);
      groups[groupKey].transactionCount++;

      if (transaction.balanceChange > 0) {
        groups[groupKey].totalCredits += Math.abs(transaction.balanceChange);
      } else {
        groups[groupKey].totalDebits += Math.abs(transaction.balanceChange);
      }

      groups[groupKey].netAmount += transaction.balanceChange;
    });

    return Object.values(groups).sort((a, b) => new Date(b.period) - new Date(a.period));
  }

  /**
   * Get transaction analytics for a company
   * @param {string} companyId - Company ID
   * @param {Object} analyticsConfig - Analytics configuration
   * @returns {Object} Transaction analytics
   */
  async getTransactionAnalytics(companyId, analyticsConfig = {}) {
    try {
      const {
        period = 30, // days
        includeComparisons = true,
        includeTrends = true,
        includePatterns = true
      } = analyticsConfig;

      const company = await CorporateCompany.findById(companyId);
      if (!company) {
        return { success: false, reason: 'Company not found' };
      }

      const endDate = new Date();
      const startDate = new Date(endDate);
      startDate.setDate(startDate.getDate() - period);

      // Get current period transactions
      const currentPeriodTransactions = await CorporateCredit.find({
        corporateCompanyId: companyId,
        transactionDate: { $gte: startDate, $lte: endDate },
        status: 'processed'
      }).sort({ transactionDate: -1 });

      // Calculate analytics
      const analytics = {
        period: {
          startDate,
          endDate,
          days: period
        },
        summary: {
          totalTransactions: currentPeriodTransactions.length,
          totalDebits: 0,
          totalCredits: 0,
          netChange: 0,
          averageTransactionSize: 0,
          largestTransaction: 0,
          frequencyPerDay: 0
        },
        breakdown: {
          byType: {},
          byCategory: {},
          byDay: {}
        }
      };

      // Process transactions
      currentPeriodTransactions.forEach(transaction => {
        const amount = Math.abs(transaction.amount);

        if (transaction.transactionType === 'debit') {
          analytics.summary.totalDebits += amount;
          analytics.summary.netChange -= amount;
        } else if (transaction.transactionType === 'credit') {
          analytics.summary.totalCredits += amount;
          analytics.summary.netChange += amount;
        }

        if (amount > analytics.summary.largestTransaction) {
          analytics.summary.largestTransaction = amount;
        }

        // Group by type
        if (!analytics.breakdown.byType[transaction.transactionType]) {
          analytics.breakdown.byType[transaction.transactionType] = { count: 0, total: 0 };
        }
        analytics.breakdown.byType[transaction.transactionType].count++;
        analytics.breakdown.byType[transaction.transactionType].total += amount;

        // Group by category
        if (!analytics.breakdown.byCategory[transaction.category]) {
          analytics.breakdown.byCategory[transaction.category] = { count: 0, total: 0 };
        }
        analytics.breakdown.byCategory[transaction.category].count++;
        analytics.breakdown.byCategory[transaction.category].total += amount;

        // Group by day
        const day = transaction.transactionDate.toISOString().split('T')[0];
        if (!analytics.breakdown.byDay[day]) {
          analytics.breakdown.byDay[day] = { count: 0, debits: 0, credits: 0 };
        }
        analytics.breakdown.byDay[day].count++;
        if (transaction.transactionType === 'debit') {
          analytics.breakdown.byDay[day].debits += amount;
        } else if (transaction.transactionType === 'credit') {
          analytics.breakdown.byDay[day].credits += amount;
        }
      });

      // Calculate averages
      if (analytics.summary.totalTransactions > 0) {
        analytics.summary.averageTransactionSize = (analytics.summary.totalDebits + analytics.summary.totalCredits) / analytics.summary.totalTransactions;
        analytics.summary.frequencyPerDay = analytics.summary.totalTransactions / period;
      }

      // Add comparison data if requested
      if (includeComparisons) {
        const previousStartDate = new Date(startDate);
        previousStartDate.setDate(previousStartDate.getDate() - period);
        const previousEndDate = new Date(startDate);

        const previousPeriodTransactions = await CorporateCredit.find({
          corporateCompanyId: companyId,
          transactionDate: { $gte: previousStartDate, $lt: previousEndDate },
          status: 'processed'
        });

        const previousTotal = previousPeriodTransactions.reduce((sum, t) => sum + Math.abs(t.amount), 0);
        const currentTotal = analytics.summary.totalDebits + analytics.summary.totalCredits;

        analytics.comparison = {
          previousPeriod: {
            totalTransactions: previousPeriodTransactions.length,
            totalAmount: previousTotal
          },
          changes: {
            transactionCount: analytics.summary.totalTransactions - previousPeriodTransactions.length,
            totalAmount: currentTotal - previousTotal,
            percentageChange: previousTotal > 0 ? ((currentTotal - previousTotal) / previousTotal * 100).toFixed(1) : 0
          }
        };
      }

      return {
        success: true,
        analytics,
        company: {
          id: company._id,
          name: company.name,
          currentBalance: company.availableCredit,
          creditLimit: company.creditLimit
        }
      };

    } catch (error) {
      console.error('Transaction analytics error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get credit monitoring summary for dashboard
   * @param {string} hotelId - Hotel ID
   * @returns {Object} Monitoring summary
   */
  async getCreditMonitoringSummary(hotelId) {
    try {
      const companies = await CorporateCompany.find({
        hotelId,
        isActive: true
      });

      const summary = {
        totalCompanies: companies.length,
        healthyCompanies: 0,
        warningCompanies: 0,
        criticalCompanies: 0,
        inactiveCompanies: 0,
        alerts: {
          total: 0,
          pending: 0,
          critical: 0
        }
      };

      // Assess each company
      companies.forEach(company => {
        const utilizationRate = company.creditLimit > 0
          ? ((company.creditLimit - company.availableCredit) / company.creditLimit) * 100
          : 0;

        if (company.availableCredit < 0) {
          summary.criticalCompanies++;
        } else if (utilizationRate > 75) {
          summary.warningCompanies++;
        } else {
          summary.healthyCompanies++;
        }
      });

      // Get active alerts
      const activeAlerts = await StaffAlert.find({
        hotelId,
        type: { $in: ['credit_warning', 'credit_critical'] },
        status: { $in: ['pending', 'acknowledged'] }
      });

      summary.alerts.total = activeAlerts.length;
      summary.alerts.pending = activeAlerts.filter(alert => alert.status === 'pending').length;
      summary.alerts.critical = activeAlerts.filter(alert => alert.priority === 'critical').length;

      return summary;

    } catch (error) {
      console.error('Error getting monitoring summary:', error);
      throw error;
    }
  }

  /**
   * Verify transaction integrity for a booking credit transaction
   * @param {string} transactionId - Transaction ID to verify
   * @param {Object} auditContext - Context for audit logging
   * @returns {Object} Integrity verification result
   */
  async verifyTransactionIntegrity(transactionId, auditContext = {}) {
    try {
      const verificationResult = await creditSecurityService.verifyTransactionIntegrity(transactionId);

      // Log the verification attempt
      await creditSecurityService.logCreditOperation({
        operation: 'TRANSACTION_INTEGRITY_CHECK',
        userId: auditContext.userId,
        details: {
          transactionId,
          isValid: verificationResult.isValid,
          reason: verificationResult.reason,
          severity: verificationResult.severity
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: verificationResult.isValid ? 'info' : 'critical',
        success: verificationResult.isValid
      });

      return verificationResult;
    } catch (error) {
      console.error('Transaction integrity verification error:', error);
      await creditSecurityService.logCreditOperation({
        operation: 'TRANSACTION_INTEGRITY_CHECK_FAILED',
        userId: auditContext.userId,
        details: {
          transactionId,
          error: error.message
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: 'high',
        success: false
      });
      return {
        isValid: false,
        reason: 'Integrity check failed',
        error: error.message
      };
    }
  }

  /**
   * Batch verify multiple transactions for integrity issues
   * @param {Array} transactionIds - Array of transaction IDs to verify
   * @param {Object} auditContext - Context for audit logging
   * @returns {Object} Batch integrity verification result
   */
  async batchVerifyTransactionIntegrity(transactionIds, auditContext = {}) {
    try {
      const results = {
        total: transactionIds.length,
        valid: [],
        invalid: [],
        errors: []
      };

      for (const transactionId of transactionIds) {
        const verificationResult = await this.verifyTransactionIntegrity(transactionId, auditContext);

        if (verificationResult.isValid) {
          results.valid.push(transactionId);
        } else {
          results.invalid.push({
            transactionId,
            reason: verificationResult.reason,
            severity: verificationResult.severity
          });
        }
      }

      // Log batch verification summary
      await creditSecurityService.logCreditOperation({
        operation: 'BATCH_TRANSACTION_INTEGRITY_CHECK',
        userId: auditContext.userId,
        details: {
          totalChecked: results.total,
          validCount: results.valid.length,
          invalidCount: results.invalid.length,
          invalidTransactions: results.invalid
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: results.invalid.length > 0 ? 'high' : 'info',
        success: results.invalid.length === 0
      });

      return results;
    } catch (error) {
      console.error('Batch transaction integrity verification error:', error);
      return {
        total: transactionIds.length,
        valid: [],
        invalid: [],
        errors: [error.message]
      };
    }
  }

  /**
   * Run daily transaction integrity audit
   * @param {string} hotelId - Hotel ID to audit
   * @param {Object} auditContext - Context for audit logging
   * @returns {Object} Daily audit result
   */
  async runDailyIntegrityAudit(hotelId, auditContext = {}) {
    try {
      // Get transactions from the last 24 hours
      const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);

      const recentTransactions = await CorporateCredit.find({
        hotelId,
        createdAt: { $gte: yesterday },
        status: 'processed'
      }).select('_id');

      const transactionIds = recentTransactions.map(t => t._id.toString());

      if (transactionIds.length === 0) {
        return {
          success: true,
          message: 'No transactions to audit',
          total: 0,
          issues: []
        };
      }

      const auditResult = await this.batchVerifyTransactionIntegrity(transactionIds, auditContext);

      // Create staff alert if integrity issues found
      if (auditResult.invalid.length > 0) {
        const adminUsers = await User.find({
          hotelId,
          role: { $in: ['admin', 'manager'] },
          isActive: true
        });

        await StaffAlert.create({
          hotelId,
          type: 'transaction_integrity_alert',
          priority: 'high',
          title: 'Transaction Integrity Issues Detected',
          message: `Daily integrity audit found ${auditResult.invalid.length} transactions with integrity issues out of ${auditResult.total} checked.`,
          data: {
            auditDate: new Date(),
            totalChecked: auditResult.total,
            issuesFound: auditResult.invalid.length,
            invalidTransactions: auditResult.invalid.slice(0, 10), // Limit to first 10 for display
            auditType: 'daily_integrity_check'
          },
          assignedTo: adminUsers.map(user => user._id),
          requiresAction: true,
          metadata: {
            createdBy: auditContext.userId,
            source: 'integrity_audit',
            autoGenerated: true
          }
        });
      }

      return {
        success: true,
        total: auditResult.total,
        valid: auditResult.valid.length,
        invalid: auditResult.invalid.length,
        issues: auditResult.invalid
      };

    } catch (error) {
      console.error('Daily integrity audit error:', error);
      return {
        success: false,
        error: error.message,
        total: 0,
        issues: []
      };
    }
  }

  /**
   * Encrypt sensitive credit data before storage
   * @param {Object} sensitiveData - Data to encrypt
   * @param {Object} auditContext - Context for audit logging
   * @returns {Object} Encrypted data with metadata
   */
  async encryptSensitiveData(sensitiveData, auditContext = {}) {
    try {
      const encryptedResult = creditSecurityService.encryptSensitiveData(sensitiveData);

      if (encryptedResult) {
        await creditSecurityService.logCreditOperation({
          operation: 'DATA_ENCRYPTION',
          userId: auditContext.userId,
          details: {
            dataType: typeof sensitiveData,
            encryptionSuccessful: true
          },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'info',
          success: true
        });

        return {
          success: true,
          encryptedData: encryptedResult
        };
      }

      await creditSecurityService.logCreditOperation({
        operation: 'DATA_ENCRYPTION_FAILED',
        userId: auditContext.userId,
        details: {
          dataType: typeof sensitiveData,
          reason: 'Encryption operation returned null'
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: 'warning',
        success: false
      });

      return {
        success: false,
        error: 'Encryption failed'
      };

    } catch (error) {
      console.error('Data encryption error:', error);
      await creditSecurityService.logCreditOperation({
        operation: 'DATA_ENCRYPTION_ERROR',
        userId: auditContext.userId,
        details: {
          error: error.message
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: 'high',
        success: false
      });

      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Decrypt sensitive credit data for display
   * @param {Object} encryptedData - Encrypted data to decrypt
   * @param {Object} auditContext - Context for audit logging
   * @returns {Object} Decrypted data
   */
  async decryptSensitiveData(encryptedData, auditContext = {}) {
    try {
      const decryptedResult = creditSecurityService.decryptSensitiveData(encryptedData);

      if (decryptedResult) {
        await creditSecurityService.logCreditOperation({
          operation: 'DATA_DECRYPTION',
          userId: auditContext.userId,
          details: {
            decryptionSuccessful: true
          },
          userAgent: auditContext.userAgent,
          ipAddress: auditContext.ipAddress,
          sessionId: auditContext.sessionId,
          severity: 'info',
          success: true
        });

        return {
          success: true,
          decryptedData: decryptedResult
        };
      }

      await creditSecurityService.logCreditOperation({
        operation: 'DATA_DECRYPTION_FAILED',
        userId: auditContext.userId,
        details: {
          reason: 'Decryption operation returned null'
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: 'warning',
        success: false
      });

      return {
        success: false,
        error: 'Decryption failed'
      };

    } catch (error) {
      console.error('Data decryption error:', error);
      await creditSecurityService.logCreditOperation({
        operation: 'DATA_DECRYPTION_ERROR',
        userId: auditContext.userId,
        details: {
          error: error.message
        },
        userAgent: auditContext.userAgent,
        ipAddress: auditContext.ipAddress,
        sessionId: auditContext.sessionId,
        severity: 'high',
        success: false
      });

      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Enhanced transaction processing with encryption for sensitive fields
   * @param {Object} transactionData - Transaction data to process
   * @param {Array} sensitiveFields - Fields to encrypt
   * @param {Object} auditContext - Context for audit logging
   * @returns {Object} Processed transaction with encrypted fields
   */
  async processSecureTransaction(transactionData, sensitiveFields = [], auditContext = {}) {
    try {
      const processedData = { ...transactionData };

      // Encrypt sensitive fields if specified
      if (sensitiveFields.length > 0) {
        const dataToEncrypt = {};
        sensitiveFields.forEach(field => {
          if (processedData[field]) {
            dataToEncrypt[field] = processedData[field];
            delete processedData[field]; // Remove from main data
          }
        });

        if (Object.keys(dataToEncrypt).length > 0) {
          const encryptionResult = await this.encryptSensitiveData(dataToEncrypt, auditContext);
          if (encryptionResult.success) {
            processedData.encryptedFields = encryptionResult.encryptedData;
            processedData.encryptedFieldsList = sensitiveFields;
          } else {
            throw new Error('Failed to encrypt sensitive data');
          }
        }
      }

      return {
        success: true,
        processedData
      };

    } catch (error) {
      console.error('Secure transaction processing error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }
}

export default new CreditMonitoringService();