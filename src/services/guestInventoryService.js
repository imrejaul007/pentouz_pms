import InventoryConsumption from '../models/InventoryConsumption.js';
import InventoryItem from '../models/InventoryItem.js';
import GuestService from '../models/GuestService.js';
import Booking from '../models/Booking.js';
import User from '../models/User.js';
import Invoice from '../models/Invoice.js';
import mongoose from 'mongoose';

/**
 * Guest Inventory Service
 * Handles personalized inventory management, VIP guest tracking,
 * automatic billing integration, and guest preference tracking
 */
class GuestInventoryService {

  /**
   * Track inventory consumption for guest services
   * @param {Object} params - Guest consumption parameters
   * @param {string} params.hotelId - Hotel ID
   * @param {string} params.guestServiceId - Guest service ID
   * @param {string} params.guestId - Guest user ID
   * @param {string} params.bookingId - Booking ID
   * @param {string} params.roomId - Room ID
   * @param {string} params.staffId - Staff member handling the service
   * @param {Array} params.consumptions - Array of consumption items
   * @returns {Promise<Object>} - Guest consumption tracking result
   */
  async trackGuestConsumption({
    hotelId,
    guestServiceId,
    guestId,
    bookingId,
    roomId,
    staffId,
    consumptions
  }) {
    try {
      const session = await mongoose.startSession();
      const results = [];

      await session.withTransaction(async () => {
        // Get guest and booking details
        const guest = await User.findById(guestId).session(session);
        const booking = await Booking.findById(bookingId).session(session);
        const guestService = await GuestService.findById(guestServiceId).session(session);

        if (!guest || !booking || !guestService) {
          throw new Error('Guest, booking, or service not found');
        }

        // Determine if guest is VIP
        const isVIPGuest = await this.isVIPGuest(guest, booking);

        for (const consumption of consumptions) {
          const {
            inventoryItemId,
            quantity,
            chargeToGuest = false,
            isComplimentary = false,
            guestSpecialRequest = false,
            notes
          } = consumption;

          // Get inventory item details
          const inventoryItem = await InventoryItem.findById(inventoryItemId).session(session);
          if (!inventoryItem) {
            throw new Error(`Inventory item ${inventoryItemId} not found`);
          }

          // Check stock availability
          if (inventoryItem.currentStock < quantity) {
            throw new Error(
              `Insufficient stock for ${inventoryItem.name}. Available: ${inventoryItem.currentStock}, Required: ${quantity}`
            );
          }

          // Apply VIP benefits and guest preferences
          const enhancedConsumption = await this.applyVIPBenefits(
            inventoryItem,
            quantity,
            isVIPGuest,
            guest,
            { chargeToGuest, isComplimentary, guestSpecialRequest }
          );

          // Create consumption record
          const consumptionRecord = new InventoryConsumption({
            hotelId,
            inventoryItemId,
            quantity,
            consumptionType: guestSpecialRequest ? 'guest_request' : 'guest_service',
            departmentType: 'guest_services',
            consumedBy: staffId,
            consumedFor: guestId,
            roomId,
            bookingId,
            guestServiceId,
            unitCost: inventoryItem.unitPrice,
            totalCost: quantity * inventoryItem.unitPrice,
            chargeToGuest: enhancedConsumption.chargeToGuest,
            guestChargeAmount: enhancedConsumption.guestChargeAmount,
            isComplimentary: enhancedConsumption.isComplimentary,
            isVIPGuest,
            specialRequirements: guestSpecialRequest ? notes : null,
            notes,
            sourceSystem: 'guest_service',
            autoGenerated: false
          });

          await consumptionRecord.save({ session });

          // Update inventory stock
          await inventoryItem.updateStock(quantity, 'subtract');

          // Track guest preferences
          await this.trackGuestPreference(
            guestId,
            hotelId,
            inventoryItemId,
            enhancedConsumption.preferenceData,
            session
          );

          // Create billing entry if chargeable
          if (enhancedConsumption.chargeToGuest && enhancedConsumption.guestChargeAmount > 0) {
            await this.createBillingEntry(consumptionRecord, booking, session);
          }

          results.push({
            consumptionId: consumptionRecord._id,
            itemName: inventoryItem.name,
            quantity,
            chargedAmount: enhancedConsumption.guestChargeAmount,
            complimentary: enhancedConsumption.isComplimentary,
            vipBenefit: enhancedConsumption.vipBenefitApplied
          });
        }
      });

      await session.endSession();

      return {
        success: true,
        consumptions: results,
        message: 'Guest inventory consumption tracked successfully'
      };

    } catch (error) {
      throw new Error(`Failed to track guest consumption: ${error.message}`);
    }
  }

  /**
   * Get personalized inventory recommendations for guest
   * @param {string} guestId - Guest user ID
   * @param {string} hotelId - Hotel ID
   * @param {string} roomId - Room ID
   * @param {string} serviceType - Type of service (room_service, spa, etc.)
   * @returns {Promise<Object>} - Personalized recommendations
   */
  async getPersonalizedRecommendations(guestId, hotelId, roomId, serviceType) {
    try {
      // Get guest preferences and history
      const guestPreferences = await this.getGuestPreferences(guestId, hotelId);
      const guest = await User.findById(guestId);
      const isVIP = await this.isVIPGuest(guest);

      // Get inventory items suitable for the service type
      const availableItems = await InventoryItem.find({
        hotelId,
        isActive: true,
        currentStock: { $gt: 0 },
        category: { $in: this.getServiceTypeCategories(serviceType) }
      });

      const recommendations = [];

      for (const item of availableItems) {
        const preference = guestPreferences.items.find(
          p => p.inventoryItemId.toString() === item._id.toString()
        );

        // Calculate recommendation score
        let score = 0;

        // Base availability score
        score += Math.min(item.currentStock / 10, 10); // Max 10 points for stock

        // Preference score (previous usage)
        if (preference) {
          score += preference.usageCount * 2; // 2 points per previous use
          score += preference.averageRating * 2; // Up to 10 points for rating
          if (preference.lastUsed) {
            const daysSinceLastUse = (new Date() - new Date(preference.lastUsed)) / (1000 * 60 * 60 * 24);
            if (daysSinceLastUse < 30) score += 5; // Recent usage bonus
          }
        }

        // VIP bonus
        if (isVIP && item.isChargeable) {
          score += 5; // VIP gets priority on premium items
        }

        // Complimentary items get a boost
        if (item.isComplimentary) {
          score += 3;
        }

        // Calculate pricing
        const pricing = this.calculateGuestPricing(item, isVIP, preference);

        recommendations.push({
          item: {
            _id: item._id,
            name: item.name,
            category: item.category,
            description: item.description,
            imageUrl: item.imageUrl,
            specifications: item.specifications
          },
          score,
          pricing,
          preference: preference ? {
            usageCount: preference.usageCount,
            averageRating: preference.averageRating,
            lastUsed: preference.lastUsed,
            notes: preference.notes
          } : null,
          availability: {
            currentStock: item.currentStock,
            available: item.currentStock > 0
          },
          vipBenefits: isVIP ? {
            discountApplied: pricing.vipDiscount > 0,
            complimentaryUpgrade: pricing.isComplimentary && !item.isComplimentary
          } : null
        });
      }

      // Sort by recommendation score
      recommendations.sort((a, b) => b.score - a.score);

      return {
        guestId,
        isVIP,
        serviceType,
        recommendations: recommendations.slice(0, 20), // Top 20 recommendations
        totalAvailable: recommendations.length,
        personalizedFactors: {
          hasPreferences: guestPreferences.items.length > 0,
          totalPreviousServices: guestPreferences.totalServices,
          averageRating: guestPreferences.averageRating
        }
      };

    } catch (error) {
      throw new Error(`Failed to get personalized recommendations: ${error.message}`);
    }
  }

  /**
   * Track and update guest preferences
   * @param {string} guestId - Guest user ID
   * @param {string} hotelId - Hotel ID
   * @param {string} inventoryItemId - Inventory item ID
   * @param {Object} preferenceData - Preference data
   * @param {Object} session - MongoDB session
   * @private
   */
  async trackGuestPreference(guestId, hotelId, inventoryItemId, preferenceData, session) {
    try {
      // This would integrate with a GuestPreferences model
      // For now, we'll store preference data in the consumption record
      const preferenceUpdate = {
        guestId,
        hotelId,
        inventoryItemId,
        lastUsed: new Date(),
        ...preferenceData
      };

      // You could implement a separate GuestPreferences collection here
      console.log('Guest preference tracked:', preferenceUpdate);

    } catch (error) {
      console.error('Failed to track guest preference:', error.message);
    }
  }

  /**
   * Apply VIP benefits and calculate enhanced pricing
   * @param {Object} inventoryItem - Inventory item
   * @param {number} quantity - Quantity requested
   * @param {boolean} isVIPGuest - Whether guest is VIP
   * @param {Object} guest - Guest user object
   * @param {Object} options - Service options
   * @returns {Promise<Object>} - Enhanced consumption data
   * @private
   */
  async applyVIPBenefits(inventoryItem, quantity, isVIPGuest, guest, options) {
    const { chargeToGuest, isComplimentary, guestSpecialRequest } = options;

    let finalChargeToGuest = chargeToGuest;
    let finalIsComplimentary = isComplimentary;
    let guestChargeAmount = 0;
    let vipBenefitApplied = false;

    // VIP benefits
    if (isVIPGuest) {
      // VIP guests get complimentary amenities
      if (inventoryItem.category === 'amenities' && quantity <= 2) {
        finalIsComplimentary = true;
        finalChargeToGuest = false;
        vipBenefitApplied = true;
      }
      // VIP discount on chargeable items
      else if (chargeToGuest && inventoryItem.isChargeable) {
        const vipDiscount = 0.2; // 20% discount for VIP
        guestChargeAmount = inventoryItem.effectiveGuestPrice * quantity * (1 - vipDiscount);
        vipBenefitApplied = true;
      }
    }

    // Standard pricing
    if (!finalIsComplimentary && finalChargeToGuest && guestChargeAmount === 0) {
      guestChargeAmount = inventoryItem.effectiveGuestPrice * quantity;
    }

    // Complimentary limit checks
    if (inventoryItem.isComplimentary && !finalChargeToGuest) {
      if (quantity <= inventoryItem.maxComplimentary) {
        finalIsComplimentary = true;
      } else {
        // Charge for excess quantity
        const complimentaryQty = inventoryItem.maxComplimentary;
        const chargeableQty = quantity - complimentaryQty;
        guestChargeAmount = inventoryItem.effectiveGuestPrice * chargeableQty;
        finalChargeToGuest = chargeableQty > 0;
      }
    }

    return {
      chargeToGuest: finalChargeToGuest,
      isComplimentary: finalIsComplimentary,
      guestChargeAmount: Math.round(guestChargeAmount * 100) / 100,
      vipBenefitApplied,
      preferenceData: {
        category: inventoryItem.category,
        vipService: vipBenefitApplied,
        specialRequest: guestSpecialRequest
      }
    };
  }

  /**
   * Create billing entry for chargeable consumption
   * @param {Object} consumptionRecord - Consumption record
   * @param {Object} booking - Booking object
   * @param {Object} session - MongoDB session
   * @private
   */
  async createBillingEntry(consumptionRecord, booking, session) {
    try {
      // This would integrate with your billing/invoice system
      const billingEntry = {
        bookingId: booking._id,
        guestId: booking.user,
        consumptionId: consumptionRecord._id,
        amount: consumptionRecord.guestChargeAmount,
        description: `Inventory charge: ${consumptionRecord.inventoryItemId}`,
        chargedAt: new Date()
      };

      // You could create an InvoiceLineItem or update an existing invoice
      console.log('Billing entry created:', billingEntry);

    } catch (error) {
      console.error('Failed to create billing entry:', error.message);
    }
  }

  /**
   * Check if guest is VIP
   * @param {Object} guest - Guest user object
   * @param {Object} booking - Booking object (optional)
   * @returns {Promise<boolean>} - Whether guest is VIP
   * @private
   */
  async isVIPGuest(guest, booking = null) {
    try {
      // VIP criteria (you can customize this logic)
      let isVIP = false;

      // Check user profile
      if (guest.vipStatus || guest.loyaltyTier === 'platinum' || guest.loyaltyTier === 'gold') {
        isVIP = true;
      }

      // Check booking value
      if (booking && booking.totalAmount > 5000) { // High-value booking
        isVIP = true;
      }

      // Check historical spending
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

      const historicalBookings = await Booking.aggregate([
        {
          $match: {
            user: guest._id,
            checkInDate: { $gte: sixMonthsAgo },
            status: { $in: ['confirmed', 'checked_in', 'checked_out'] }
          }
        },
        {
          $group: {
            _id: null,
            totalSpent: { $sum: '$totalAmount' },
            bookingCount: { $sum: 1 }
          }
        }
      ]);

      if (historicalBookings.length > 0) {
        const { totalSpent, bookingCount } = historicalBookings[0];
        if (totalSpent > 10000 || bookingCount > 5) { // Frequent/high-value guest
          isVIP = true;
        }
      }

      return isVIP;

    } catch (error) {
      console.error('Failed to check VIP status:', error.message);
      return false;
    }
  }

  /**
   * Get guest preferences and history
   * @param {string} guestId - Guest user ID
   * @param {string} hotelId - Hotel ID
   * @returns {Promise<Object>} - Guest preferences
   * @private
   */
  async getGuestPreferences(guestId, hotelId) {
    try {
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

      const preferences = await InventoryConsumption.aggregate([
        {
          $match: {
            hotelId: new mongoose.Types.ObjectId(hotelId),
            consumedFor: new mongoose.Types.ObjectId(guestId),
            consumedAt: { $gte: sixMonthsAgo }
          }
        },
        {
          $group: {
            _id: '$inventoryItemId',
            usageCount: { $sum: 1 },
            totalQuantity: { $sum: '$quantity' },
            lastUsed: { $max: '$consumedAt' },
            avgCharge: { $avg: '$guestChargeAmount' },
            categories: { $addToSet: '$consumptionType' }
          }
        },
        {
          $lookup: {
            from: 'inventoryitems',
            localField: '_id',
            foreignField: '_id',
            as: 'item'
          }
        },
        { $unwind: '$item' },
        { $sort: { usageCount: -1 } }
      ]);

      // Get guest's service ratings (if available)
      const serviceRatings = await GuestService.aggregate([
        {
          $match: {
            hotelId: new mongoose.Types.ObjectId(hotelId),
            userId: new mongoose.Types.ObjectId(guestId),
            rating: { $exists: true }
          }
        },
        {
          $group: {
            _id: null,
            averageRating: { $avg: '$rating' },
            totalServices: { $sum: 1 }
          }
        }
      ]);

      return {
        items: preferences.map(pref => ({
          inventoryItemId: pref._id,
          itemName: pref.item.name,
          category: pref.item.category,
          usageCount: pref.usageCount,
          totalQuantity: pref.totalQuantity,
          lastUsed: pref.lastUsed,
          averageCharge: Math.round((pref.avgCharge || 0) * 100) / 100,
          averageRating: 4.0, // Default rating, could be calculated from feedback
          categories: pref.categories
        })),
        averageRating: serviceRatings[0]?.averageRating || 0,
        totalServices: serviceRatings[0]?.totalServices || 0
      };

    } catch (error) {
      console.error('Failed to get guest preferences:', error.message);
      return { items: [], averageRating: 0, totalServices: 0 };
    }
  }

  /**
   * Calculate guest pricing with VIP considerations
   * @param {Object} item - Inventory item
   * @param {boolean} isVIP - Whether guest is VIP
   * @param {Object} preference - Guest preference data
   * @returns {Object} - Pricing information
   * @private
   */
  calculateGuestPricing(item, isVIP, preference) {
    let basePrice = item.effectiveGuestPrice;
    let finalPrice = basePrice;
    let vipDiscount = 0;
    let isComplimentary = item.isComplimentary;

    // VIP pricing
    if (isVIP) {
      if (item.category === 'amenities') {
        isComplimentary = true;
        finalPrice = 0;
      } else if (item.isChargeable) {
        vipDiscount = 0.2; // 20% VIP discount
        finalPrice = basePrice * (1 - vipDiscount);
      }
    }

    // Loyalty pricing (based on usage history)
    if (preference && preference.usageCount > 5) {
      const loyaltyDiscount = Math.min(preference.usageCount * 0.02, 0.15); // Max 15% loyalty discount
      finalPrice = finalPrice * (1 - loyaltyDiscount);
    }

    return {
      basePrice: Math.round(basePrice * 100) / 100,
      finalPrice: Math.round(finalPrice * 100) / 100,
      vipDiscount: Math.round(vipDiscount * 100),
      isComplimentary,
      savings: Math.round((basePrice - finalPrice) * 100) / 100
    };
  }

  /**
   * Get inventory categories for service type
   * @param {string} serviceType - Service type
   * @returns {Array} - Array of inventory categories
   * @private
   */
  getServiceTypeCategories(serviceType) {
    const categoryMap = {
      'room_service': ['minibar', 'amenities', 'toiletries'],
      'housekeeping': ['bedding', 'toiletries', 'cleaning', 'amenities'],
      'spa': ['amenities', 'toiletries'],
      'concierge': ['amenities'],
      'maintenance': ['electronics', 'furniture'],
      'other': ['amenities', 'toiletries', 'minibar']
    };

    return categoryMap[serviceType] || ['amenities'];
  }

  /**
   * Get guest consumption analytics
   * @param {string} hotelId - Hotel ID
   * @param {Object} filters - Filter options
   * @returns {Promise<Object>} - Guest consumption analytics
   */
  async getGuestConsumptionAnalytics(hotelId, filters = {}) {
    try {
      const {
        startDate,
        endDate,
        guestId,
        vipOnly = false
      } = filters;

      const matchQuery = {
        hotelId: new mongoose.Types.ObjectId(hotelId),
        consumptionType: { $in: ['guest_service', 'guest_request'] },
        consumedFor: { $exists: true }
      };

      if (startDate && endDate) {
        matchQuery.consumedAt = {
          $gte: new Date(startDate),
          $lte: new Date(endDate)
        };
      }

      if (guestId) {
        matchQuery.consumedFor = new mongoose.Types.ObjectId(guestId);
      }

      if (vipOnly) {
        matchQuery.isVIPGuest = true;
      }

      const analytics = await InventoryConsumption.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: '$consumedFor',
            totalConsumptions: { $sum: 1 },
            totalCost: { $sum: '$totalCost' },
            totalRevenue: { $sum: { $cond: ['$chargeToGuest', '$guestChargeAmount', 0] } },
            complimentaryValue: { $sum: { $cond: ['$isComplimentary', '$totalCost', 0] } },
            uniqueItems: { $addToSet: '$inventoryItemId' },
            categories: { $addToSet: '$inventoryItemId' },
            isVIP: { $first: '$isVIPGuest' },
            avgConsumptionValue: { $avg: '$guestChargeAmount' }
          }
        },
        {
          $addFields: {
            uniqueItemCount: { $size: '$uniqueItems' },
            profitMargin: { $subtract: ['$totalRevenue', '$totalCost'] }
          }
        },
        {
          $lookup: {
            from: 'users',
            localField: '_id',
            foreignField: '_id',
            as: 'guest'
          }
        },
        { $unwind: '$guest' },
        { $sort: { totalRevenue: -1 } }
      ]);

      const summary = analytics.reduce((acc, guest) => {
        acc.totalGuests += 1;
        acc.totalRevenue += guest.totalRevenue;
        acc.totalCost += guest.totalCost;
        acc.totalConsumptions += guest.totalConsumptions;
        acc.totalComplimentaryValue += guest.complimentaryValue;
        if (guest.isVIP) acc.vipGuests += 1;
        return acc;
      }, {
        totalGuests: 0,
        totalRevenue: 0,
        totalCost: 0,
        totalConsumptions: 0,
        totalComplimentaryValue: 0,
        vipGuests: 0
      });

      return {
        guestAnalytics: analytics.map(guest => ({
          guestId: guest._id,
          guestName: guest.guest.name,
          guestEmail: guest.guest.email,
          isVIP: guest.isVIP,
          totalConsumptions: guest.totalConsumptions,
          totalCost: Math.round(guest.totalCost * 100) / 100,
          totalRevenue: Math.round(guest.totalRevenue * 100) / 100,
          profitMargin: Math.round(guest.profitMargin * 100) / 100,
          complimentaryValue: Math.round(guest.complimentaryValue * 100) / 100,
          uniqueItemCount: guest.uniqueItemCount,
          avgConsumptionValue: Math.round((guest.avgConsumptionValue || 0) * 100) / 100
        })),
        summary: {
          ...summary,
          totalRevenue: Math.round(summary.totalRevenue * 100) / 100,
          totalCost: Math.round(summary.totalCost * 100) / 100,
          totalComplimentaryValue: Math.round(summary.totalComplimentaryValue * 100) / 100,
          avgRevenuePerGuest: summary.totalGuests > 0
            ? Math.round((summary.totalRevenue / summary.totalGuests) * 100) / 100
            : 0,
          vipPercentage: summary.totalGuests > 0
            ? Math.round((summary.vipGuests / summary.totalGuests) * 100)
            : 0
        }
      };

    } catch (error) {
      throw new Error(`Failed to get guest consumption analytics: ${error.message}`);
    }
  }
}

export default new GuestInventoryService();