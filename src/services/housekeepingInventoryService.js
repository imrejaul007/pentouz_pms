import InventoryConsumption from '../models/InventoryConsumption.js';
import InventoryItem from '../models/InventoryItem.js';
import HousekeepingTask from '../models/HousekeepingTask.js';
import Room from '../models/Room.js';
import mongoose from 'mongoose';

/**
 * Housekeeping Inventory Service
 * Handles real-time consumption tracking, prediction algorithms,
 * and efficiency analytics for housekeeping operations
 */
class HousekeepingInventoryService {

  /**
   * Track inventory consumption for a housekeeping task
   * @param {Object} params - Consumption parameters
   * @param {string} params.hotelId - Hotel ID
   * @param {string} params.housekeepingTaskId - Housekeeping task ID
   * @param {string} params.roomId - Room ID
   * @param {string} params.staffId - Staff member ID
   * @param {Array} params.consumptions - Array of consumption items
   * @returns {Promise<Object>} - Consumption tracking result
   */
  async trackConsumption({
    hotelId,
    housekeepingTaskId,
    roomId,
    staffId,
    consumptions
  }) {
    try {
      const session = await mongoose.startSession();
      const results = [];

      await session.withTransaction(async () => {
        for (const consumption of consumptions) {
          const {
            inventoryItemId,
            quantity,
            notes,
            replacementType,
            isComplimentary = true
          } = consumption;

          // Get inventory item details
          const inventoryItem = await InventoryItem.findById(inventoryItemId).session(session);
          if (!inventoryItem) {
            throw new Error(`Inventory item ${inventoryItemId} not found`);
          }

          // Check if sufficient stock is available
          if (inventoryItem.currentStock < quantity) {
            throw new Error(
              `Insufficient stock for ${inventoryItem.name}. Available: ${inventoryItem.currentStock}, Required: ${quantity}`
            );
          }

          // Get expected consumption for efficiency calculation
          const expectedConsumption = await this.getExpectedConsumption(
            hotelId,
            roomId,
            inventoryItemId,
            'housekeeping'
          );

          // Create consumption record
          const consumptionRecord = new InventoryConsumption({
            hotelId,
            inventoryItemId,
            quantity,
            consumptionType: replacementType ? 'replacement' : 'housekeeping',
            departmentType: 'housekeeping',
            consumedBy: staffId,
            roomId,
            housekeepingTaskId,
            unitCost: inventoryItem.unitPrice,
            totalCost: quantity * inventoryItem.unitPrice,
            chargeToGuest: !isComplimentary && replacementType,
            guestChargeAmount: replacementType ? inventoryItem.effectiveReplacementPrice * quantity : 0,
            isComplimentary,
            replacementType,
            expectedQuantity: expectedConsumption?.avgQuantity || null,
            notes,
            sourceSystem: 'housekeeping',
            autoGenerated: false
          });

          await consumptionRecord.save({ session });

          // Update inventory stock
          await inventoryItem.updateStock(quantity, 'subtract');

          // Check for low stock and create alerts if needed
          if (inventoryItem.isLowStock) {
            await this.createLowStockAlert(inventoryItem, session);
          }

          results.push({
            consumptionId: consumptionRecord._id,
            itemName: inventoryItem.name,
            quantity,
            efficiency: consumptionRecord.efficiency,
            costEfficiency: consumptionRecord.costEfficiency
          });
        }
      });

      await session.endSession();

      // Update task efficiency metrics
      await this.updateTaskEfficiencyMetrics(housekeepingTaskId, results);

      return {
        success: true,
        consumptions: results,
        message: 'Inventory consumption tracked successfully'
      };

    } catch (error) {
      throw new Error(`Failed to track housekeeping consumption: ${error.message}`);
    }
  }

  /**
   * Get predicted inventory consumption for a housekeeping task
   * @param {string} hotelId - Hotel ID
   * @param {string} roomId - Room ID
   * @param {Array} taskTypes - Array of task types
   * @returns {Promise<Object>} - Predicted consumption
   */
  async predictConsumption(hotelId, roomId, taskTypes = []) {
    try {
      // Get room details
      const room = await Room.findById(roomId).populate('roomType');
      if (!room) {
        throw new Error('Room not found');
      }

      // Get historical consumption patterns
      const predictions = await InventoryConsumption.predictHousekeepingConsumption(
        hotelId,
        room.roomType._id,
        taskTypes
      );

      // Group predictions by inventory item
      const predictionMap = new Map();

      for (const prediction of predictions) {
        const itemId = prediction._id.inventoryItemId.toString();

        if (!predictionMap.has(itemId)) {
          predictionMap.set(itemId, {
            inventoryItem: prediction.item,
            predictions: [],
            totalAvgQuantity: 0,
            confidence: 0
          });
        }

        const itemPrediction = predictionMap.get(itemId);
        itemPrediction.predictions.push(prediction);
        itemPrediction.totalAvgQuantity += prediction.avgQuantity;
      }

      // Calculate confidence scores and recommended quantities
      const recommendations = [];

      for (const [itemId, data] of predictionMap) {
        const { inventoryItem, predictions, totalAvgQuantity } = data;

        // Calculate confidence based on historical data points
        const totalConsumptions = predictions.reduce((sum, p) => sum + p.totalConsumptions, 0);
        const confidence = Math.min(totalConsumptions * 10, 100); // Max 100% confidence

        // Calculate recommended quantity with safety margin
        const baseQuantity = totalAvgQuantity / predictions.length;
        const safetyMargin = this.calculateSafetyMargin(predictions);
        const recommendedQuantity = Math.ceil(baseQuantity * (1 + safetyMargin));

        recommendations.push({
          inventoryItem: {
            _id: inventoryItem._id,
            name: inventoryItem.name,
            category: inventoryItem.category,
            currentStock: inventoryItem.currentStock,
            unitPrice: inventoryItem.unitPrice
          },
          recommendedQuantity,
          confidence,
          historicalAverage: Math.round(baseQuantity * 100) / 100,
          safetyMargin: Math.round(safetyMargin * 100),
          predictions: predictions.map(p => ({
            taskType: p._id.taskType,
            avgQuantity: Math.round(p.avgQuantity * 100) / 100,
            dataPoints: p.totalConsumptions
          }))
        });
      }

      // Sort by confidence and quantity
      recommendations.sort((a, b) => {
        if (b.confidence !== a.confidence) return b.confidence - a.confidence;
        return b.recommendedQuantity - a.recommendedQuantity;
      });

      return {
        roomId,
        roomNumber: room.roomNumber,
        roomType: room.roomType.name,
        taskTypes,
        recommendations,
        totalItems: recommendations.length,
        averageConfidence: recommendations.length > 0
          ? recommendations.reduce((sum, r) => sum + r.confidence, 0) / recommendations.length
          : 0
      };

    } catch (error) {
      throw new Error(`Failed to predict consumption: ${error.message}`);
    }
  }

  /**
   * Get room-type based inventory allocation algorithms
   * @param {string} hotelId - Hotel ID
   * @param {string} roomTypeId - Room type ID
   * @returns {Promise<Object>} - Allocation recommendations
   */
  async getRoomTypeAllocation(hotelId, roomTypeId) {
    try {
      // Get rooms of this type
      const rooms = await Room.find({ hotelId, roomType: roomTypeId });
      const roomIds = rooms.map(r => r._id);

      // Get consumption patterns for this room type
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      const consumptionStats = await InventoryConsumption.aggregate([
        {
          $match: {
            hotelId: new mongoose.Types.ObjectId(hotelId),
            roomId: { $in: roomIds },
            consumptionType: 'housekeeping',
            consumedAt: { $gte: thirtyDaysAgo }
          }
        },
        {
          $group: {
            _id: '$inventoryItemId',
            avgDailyConsumption: {
              $avg: {
                $divide: [
                  '$quantity',
                  { $divide: [{ $subtract: [new Date(), '$consumedAt'] }, 1000 * 60 * 60 * 24] }
                ]
              }
            },
            totalConsumption: { $sum: '$quantity' },
            maxSingleConsumption: { $max: '$quantity' },
            consumptionCount: { $sum: 1 }
          }
        },
        {
          $lookup: {
            from: 'inventoryitems',
            localField: '_id',
            foreignField: '_id',
            as: 'item'
          }
        },
        { $unwind: '$item' },
        {
          $project: {
            item: 1,
            avgDailyConsumption: 1,
            totalConsumption: 1,
            maxSingleConsumption: 1,
            consumptionCount: 1,
            recommendedStockPerRoom: {
              $multiply: [
                { $ceil: '$avgDailyConsumption' },
                7 // One week supply
              ]
            },
            totalRecommendedStock: {
              $multiply: [
                { $multiply: [{ $ceil: '$avgDailyConsumption' }, 7] },
                roomIds.length
              ]
            }
          }
        },
        { $sort: { totalConsumption: -1 } }
      ]);

      return {
        roomTypeId,
        totalRooms: rooms.length,
        allocationPeriod: '7 days',
        recommendations: consumptionStats,
        totalEstimatedCost: consumptionStats.reduce(
          (sum, stat) => sum + (stat.totalRecommendedStock * stat.item.unitPrice),
          0
        )
      };

    } catch (error) {
      throw new Error(`Failed to calculate room type allocation: ${error.message}`);
    }
  }

  /**
   * Get efficiency analytics for housekeeping staff
   * @param {string} hotelId - Hotel ID
   * @param {Object} filters - Filter options
   * @returns {Promise<Object>} - Staff efficiency analytics
   */
  async getStaffEfficiencyAnalytics(hotelId, filters = {}) {
    try {
      const {
        startDate,
        endDate,
        staffId,
        roomType,
        taskType
      } = filters;

      const matchQuery = {
        hotelId: new mongoose.Types.ObjectId(hotelId),
        consumptionType: 'housekeeping',
        consumedBy: { $exists: true },
        efficiency: { $exists: true }
      };

      if (startDate && endDate) {
        matchQuery.consumedAt = {
          $gte: new Date(startDate),
          $lte: new Date(endDate)
        };
      }

      if (staffId) {
        matchQuery.consumedBy = new mongoose.Types.ObjectId(staffId);
      }

      // Staff efficiency aggregation
      const staffStats = await InventoryConsumption.aggregate([
        { $match: matchQuery },
        {
          $lookup: {
            from: 'housekeepingtasks',
            localField: 'housekeepingTaskId',
            foreignField: '_id',
            as: 'task'
          }
        },
        { $unwind: { path: '$task', preserveNullAndEmptyArrays: true } },
        {
          $lookup: {
            from: 'rooms',
            localField: 'roomId',
            foreignField: '_id',
            as: 'room'
          }
        },
        { $unwind: { path: '$room', preserveNullAndEmptyArrays: true } },
        {
          $match: roomType ? { 'room.roomType': new mongoose.Types.ObjectId(roomType) } : {}
        },
        {
          $group: {
            _id: '$consumedBy',
            avgEfficiency: { $avg: '$efficiency' },
            totalTasks: { $sum: 1 },
            totalCost: { $sum: '$totalCost' },
            totalQuantity: { $sum: '$quantity' },
            uniqueRooms: { $addToSet: '$roomId' },
            taskTypes: { $addToSet: '$task.tasks' },
            costPerTask: { $avg: '$totalCost' },
            quantityPerTask: { $avg: '$quantity' }
          }
        },
        {
          $addFields: {
            uniqueRoomCount: { $size: '$uniqueRooms' },
            efficiency_rating: {
              $switch: {
                branches: [
                  { case: { $gte: ['$avgEfficiency', 95] }, then: 'Excellent' },
                  { case: { $gte: ['$avgEfficiency', 85] }, then: 'Good' },
                  { case: { $gte: ['$avgEfficiency', 75] }, then: 'Average' },
                  { case: { $gte: ['$avgEfficiency', 65] }, then: 'Below Average' }
                ],
                default: 'Needs Improvement'
              }
            }
          }
        },
        {
          $lookup: {
            from: 'users',
            localField: '_id',
            foreignField: '_id',
            as: 'staff'
          }
        },
        { $unwind: '$staff' },
        { $sort: { avgEfficiency: -1 } }
      ]);

      // Calculate department averages
      const departmentAverage = staffStats.length > 0
        ? staffStats.reduce((sum, staff) => sum + staff.avgEfficiency, 0) / staffStats.length
        : 0;

      const totalCost = staffStats.reduce((sum, staff) => sum + staff.totalCost, 0);
      const totalTasks = staffStats.reduce((sum, staff) => sum + staff.totalTasks, 0);

      return {
        staffAnalytics: staffStats.map(staff => ({
          staffId: staff._id,
          staffName: staff.staff.name,
          avgEfficiency: Math.round(staff.avgEfficiency * 100) / 100,
          efficiencyRating: staff.efficiency_rating,
          totalTasks: staff.totalTasks,
          totalCost: Math.round(staff.totalCost * 100) / 100,
          costPerTask: Math.round(staff.costPerTask * 100) / 100,
          quantityPerTask: Math.round(staff.quantityPerTask * 100) / 100,
          uniqueRoomsServiced: staff.uniqueRoomCount,
          taskTypes: staff.taskTypes.flat().filter(Boolean)
        })),
        departmentSummary: {
          averageEfficiency: Math.round(departmentAverage * 100) / 100,
          totalStaff: staffStats.length,
          totalCost: Math.round(totalCost * 100) / 100,
          totalTasks,
          avgCostPerTask: totalTasks > 0 ? Math.round((totalCost / totalTasks) * 100) / 100 : 0
        }
      };

    } catch (error) {
      throw new Error(`Failed to get staff efficiency analytics: ${error.message}`);
    }
  }

  /**
   * Get consumption trends and patterns
   * @param {string} hotelId - Hotel ID
   * @param {Object} options - Options for trend analysis
   * @returns {Promise<Object>} - Consumption trends
   */
  async getConsumptionTrends(hotelId, options = {}) {
    try {
      const {
        period = 'daily',
        itemCategory,
        roomType,
        days = 30
      } = options;

      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const matchQuery = {
        hotelId: new mongoose.Types.ObjectId(hotelId),
        consumptionType: 'housekeeping',
        consumedAt: { $gte: startDate, $lte: endDate }
      };

      if (itemCategory) {
        const items = await InventoryItem.find({
          hotelId,
          category: itemCategory,
          isActive: true
        }).select('_id');
        matchQuery.inventoryItemId = { $in: items.map(i => i._id) };
      }

      // Get consumption trends
      const trends = await InventoryConsumption.getConsumptionTrends(hotelId, period, days);

      // Get peak consumption hours
      const peakHours = await InventoryConsumption.aggregate([
        { $match: matchQuery },
        {
          $group: {
            _id: { $hour: '$consumedAt' },
            count: { $sum: 1 },
            totalQuantity: { $sum: '$quantity' },
            avgEfficiency: { $avg: '$efficiency' }
          }
        },
        { $sort: { totalQuantity: -1 } },
        { $limit: 5 }
      ]);

      // Get most consumed items
      const topItems = await InventoryConsumption.getTopConsumingItems(
        hotelId,
        10,
        { start: startDate, end: endDate }
      );

      return {
        trends: trends.map(trend => ({
          date: trend._id,
          totalQuantity: trend.totalQuantity,
          totalCost: Math.round(trend.totalCost * 100) / 100,
          avgEfficiency: Math.round((trend.avgEfficiency || 0) * 100) / 100,
          uniqueItems: trend.uniqueItemCount,
          consumptionCount: trend.consumptionCount
        })),
        peakHours: peakHours.map(hour => ({
          hour: hour._id,
          count: hour.count,
          totalQuantity: hour.totalQuantity,
          avgEfficiency: Math.round((hour.avgEfficiency || 0) * 100) / 100
        })),
        topConsumingItems: topItems.map(item => ({
          item: {
            name: item.item.name,
            category: item.item.category,
            unitPrice: item.item.unitPrice
          },
          totalQuantity: item.totalQuantity,
          totalCost: Math.round(item.totalCost * 100) / 100,
          consumptionCount: item.consumptionCount,
          avgEfficiency: Math.round((item.avgEfficiency || 0) * 100) / 100
        })),
        summary: {
          analysisPeriod: `${days} days`,
          startDate,
          endDate,
          totalDataPoints: trends.length
        }
      };

    } catch (error) {
      throw new Error(`Failed to get consumption trends: ${error.message}`);
    }
  }

  /**
   * Auto-consume inventory when housekeeping task is completed
   * @param {string} housekeepingTaskId - Housekeeping task ID
   * @returns {Promise<Object>} - Auto-consumption result
   */
  async autoConsumeOnTaskCompletion(housekeepingTaskId) {
    try {
      const task = await HousekeepingTask.findById(housekeepingTaskId)
        .populate('roomId')
        .populate('assignedTo');

      if (!task) {
        throw new Error('Housekeeping task not found');
      }

      if (task.status !== 'completed') {
        throw new Error('Task must be completed before auto-consumption');
      }

      // Get predicted consumption for this task
      const predictions = await this.predictConsumption(
        task.hotelId,
        task.roomId._id,
        task.tasks
      );

      const autoConsumptions = [];

      // Auto-consume items with high confidence predictions
      for (const recommendation of predictions.recommendations) {
        if (recommendation.confidence >= 70 && recommendation.recommendedQuantity > 0) {
          // Check if we have enough stock
          const item = await InventoryItem.findById(recommendation.inventoryItem._id);

          if (item && item.currentStock >= recommendation.recommendedQuantity) {
            const consumption = {
              inventoryItemId: item._id,
              quantity: recommendation.recommendedQuantity,
              notes: `Auto-consumed based on ${recommendation.confidence}% confidence prediction`,
              isComplimentary: true
            };

            autoConsumptions.push(consumption);
          }
        }
      }

      if (autoConsumptions.length > 0) {
        const result = await this.trackConsumption({
          hotelId: task.hotelId,
          housekeepingTaskId: task._id,
          roomId: task.roomId._id,
          staffId: task.assignedTo._id,
          consumptions: autoConsumptions
        });

        return {
          success: true,
          autoGenerated: true,
          consumptionsCreated: result.consumptions.length,
          consumptions: result.consumptions,
          message: 'Inventory automatically consumed based on predictions'
        };
      }

      return {
        success: true,
        autoGenerated: false,
        consumptionsCreated: 0,
        message: 'No confident predictions available for auto-consumption'
      };

    } catch (error) {
      throw new Error(`Failed to auto-consume inventory: ${error.message}`);
    }
  }

  // Helper methods

  /**
   * Calculate safety margin for inventory predictions
   * @private
   */
  calculateSafetyMargin(predictions) {
    if (!predictions || predictions.length === 0) return 0.2; // 20% default

    const quantities = predictions.map(p => p.avgQuantity);
    const mean = quantities.reduce((sum, q) => sum + q, 0) / quantities.length;
    const variance = quantities.reduce((sum, q) => sum + Math.pow(q - mean, 2), 0) / quantities.length;
    const coefficient_of_variation = Math.sqrt(variance) / mean;

    // Higher variability = higher safety margin (max 50%)
    return Math.min(coefficient_of_variation, 0.5);
  }

  /**
   * Get expected consumption for efficiency calculation
   * @private
   */
  async getExpectedConsumption(hotelId, roomId, inventoryItemId, taskType) {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const historicalData = await InventoryConsumption.aggregate([
      {
        $match: {
          hotelId: new mongoose.Types.ObjectId(hotelId),
          roomId: new mongoose.Types.ObjectId(roomId),
          inventoryItemId: new mongoose.Types.ObjectId(inventoryItemId),
          consumptionType: taskType,
          consumedAt: { $gte: thirtyDaysAgo }
        }
      },
      {
        $group: {
          _id: null,
          avgQuantity: { $avg: '$quantity' },
          count: { $sum: 1 }
        }
      }
    ]);

    return historicalData[0] || null;
  }

  /**
   * Create low stock alert
   * @private
   */
  async createLowStockAlert(inventoryItem, session) {
    // This would integrate with your notification system
    // For now, we'll just log the alert
    console.log(`Low stock alert for ${inventoryItem.name}: ${inventoryItem.currentStock} remaining`);

    // You could create a StaffAlert here or send a notification
    // depending on your notification system implementation
  }

  /**
   * Update task efficiency metrics
   * @private
   */
  async updateTaskEfficiencyMetrics(housekeepingTaskId, consumptions) {
    try {
      const avgEfficiency = consumptions.reduce((sum, c) => sum + (c.efficiency || 0), 0) / consumptions.length;

      // You could update the HousekeepingTask model with efficiency data
      // or create separate efficiency tracking records
      console.log(`Task ${housekeepingTaskId} efficiency: ${avgEfficiency}%`);
    } catch (error) {
      console.error('Failed to update task efficiency metrics:', error.message);
    }
  }
}

export default new HousekeepingInventoryService();