import mongoose from 'mongoose';

// Audit Log model for tracking all changes to rates/inventory/reservations
const auditLogSchema = new mongoose.Schema({
    logId: {
        type: String,
        required: false, // Will be generated by pre-save hook
        unique: true,
        sparse: true
    },
    hotelId: {
        type: mongoose.Schema.ObjectId,
        ref: 'Hotel',
        required: true
    },
    // What was changed
    tableName: {
        type: String,
        required: true,
        enum: ['RoomAvailability', 'RoomType', 'Booking', 'RatePlan', 'Channel', 'Room', 'User', 'BookingFormTemplate', 'WebSettings', 'AdminBypassAudit', 'BypassApprovalWorkflow', 'BypassFinancialImpact'],
        index: true
    },
    recordId: {
        type: mongoose.Schema.Types.Mixed, // Can be ObjectId or String
        required: true,
        index: true
    },
    // Type of change
    changeType: {
        type: String,
        required: true,
        enum: ['create', 'update', 'delete', 'sync', 'booking', 'cancellation', 'web_settings_update', 'web_settings_section_update_general', 'web_settings_section_update_booking', 'web_settings_section_update_payment', 'web_settings_section_update_seo', 'web_settings_section_update_integrations', 'web_settings_section_update_theme', 'web_settings_section_update_advanced', 'web_settings_section_update_maintenance', 'web_settings_export', 'web_settings_import', 'web_settings_reset', 'security_event', 'bypass_operation', 'bypass_completed', 'approval_received', 'workflow_escalated'],
        index: true
    },
    // Change details
    oldValues: {
        type: mongoose.Schema.Types.Mixed,
        default: {}
    },
    newValues: {
        type: mongoose.Schema.Types.Mixed,
        default: {}
    },
    changedFields: [{
        field: String,
        oldValue: mongoose.Schema.Types.Mixed,
        newValue: mongoose.Schema.Types.Mixed
    }],
    // Context information
    userId: {
        type: mongoose.Schema.ObjectId,
        ref: 'User'
    },
    userEmail: String,
    userRole: String,
    source: {
        type: String,
        enum: ['manual', 'api', 'channel_sync', 'system', 'migration', 'channel_setup', 'booking_com_webhook', 'expedia_webhook', 'webhook', 'room_mapping', 'web_settings_controller', 'bypass_security_service', 'enhanced_bypass_system', 'bypass_approval_system'],
        default: 'manual'
    },
    sourceDetails: {
        channel: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Channel'
        },
        channelName: String,
        apiEndpoint: String,
        userAgent: String,
        ipAddress: String,
        sessionId: String
    },
    // For booking-related audits
    bookingDetails: {
        bookingNumber: String,
        checkIn: Date,
        checkOut: Date,
        roomType: String,
        guestName: String,
        totalAmount: Number,
        source: String
    },
    // For inventory/rate changes
    inventoryDetails: {
        date: Date,
        roomTypeId: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'RoomType'
        },
        roomTypeName: String,
        availableRooms: Number,
        soldRooms: Number,
        rate: Number,
        restrictions: mongoose.Schema.Types.Mixed
    },
    // Error information (for failed syncs)
    error: {
        message: String,
        code: String,
        stack: String
    },
    // Reconciliation info
    reconciliation: {
        status: {
            type: String,
            enum: ['pending', 'reconciled', 'discrepancy'],
            default: 'pending'
        },
        reconciledAt: Date,
        reconciledBy: {
            type: mongoose.Schema.ObjectId,
            ref: 'User'
        },
        notes: String
    },
    // Additional metadata
    metadata: {
        batchId: String, // For bulk operations
        correlationId: String, // For tracking related changes
        priority: {
            type: String,
            enum: ['low', 'medium', 'high', 'critical'],
            default: 'medium'
        },
        tags: [String]
    },
    // Retention
    retentionDate: {
        type: Date,
        index: {
            expireAfterSeconds: 0
        }
    }
}, {
    timestamps: true
});

// Indexes for performance
auditLogSchema.index({
    hotelId: 1,
    createdAt: -1
});
auditLogSchema.index({
    tableName: 1,
    recordId: 1,
    createdAt: -1
});
auditLogSchema.index({
    userId: 1,
    createdAt: -1
});
auditLogSchema.index({
    source: 1,
    createdAt: -1
});
auditLogSchema.index({
    'sourceDetails.channel': 1,
    createdAt: -1
});
auditLogSchema.index({
    'reconciliation.status': 1
});
auditLogSchema.index({
    'metadata.batchId': 1
});
auditLogSchema.index({
    'metadata.correlationId': 1
});

// Pre-save middleware to generate logId and set retention
auditLogSchema.pre('save', function(next) {
    // Generate unique log ID
    if (!this.logId) {
        const timestamp = Date.now().toString();
        const random = Math.random().toString(36).substring(7);
        this.logId = `AUDIT_${timestamp}_${random}`;
    }

    // Set retention date (default 2 years for bookings, 1 year for others)
    if (!this.retentionDate) {
        const retentionMonths = this.changeType === 'booking' ? 24 : 12;
        this.retentionDate = new Date(Date.now() + (retentionMonths * 30 * 24 * 60 * 60 * 1000));
    }

    next();
});

// Static methods
auditLogSchema.statics.logChange = async function(data) {
    const logEntry = {
        hotelId: data.hotelId,
        tableName: data.tableName,
        recordId: data.recordId,
        changeType: data.changeType,
        oldValues: data.oldValues || {},
        newValues: data.newValues || {},
        userId: data.userId,
        userEmail: data.userEmail,
        userRole: data.userRole,
        source: data.source || 'manual',
        sourceDetails: data.sourceDetails || {},
        bookingDetails: data.bookingDetails || {},
        inventoryDetails: data.inventoryDetails || {},
        error: data.error,
        metadata: data.metadata || {}
    };

    // Calculate changed fields
    if (data.oldValues && data.newValues) {
        logEntry.changedFields = [];
        const allFields = new Set([...Object.keys(data.oldValues), ...Object.keys(data.newValues)]);

        for (const field of allFields) {
            const oldValue = data.oldValues[field];
            const newValue = data.newValues[field];

            if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
                logEntry.changedFields.push({
                    field,
                    oldValue,
                    newValue
                });
            }
        }
    }

    return await this.create(logEntry);
};

auditLogSchema.statics.logBookingChange = async function(booking, changeType, userId, additionalData = {}) {
    return await this.logChange({
        hotelId: booking.hotelId,
        tableName: 'Booking',
        recordId: booking._id,
        changeType,
        userId,
        bookingDetails: {
            bookingNumber: booking.bookingNumber,
            checkIn: booking.checkIn,
            checkOut: booking.checkOut,
            roomType: booking.roomType,
            totalAmount: booking.totalAmount,
            source: booking.source
        },
        ...additionalData
    });
};

auditLogSchema.statics.logInventoryChange = async function(availability, changeType, userId, additionalData = {}) {
    return await this.logChange({
        hotelId: availability.hotelId,
        tableName: 'RoomAvailability',
        recordId: availability._id,
        changeType,
        userId,
        inventoryDetails: {
            date: availability.date,
            roomTypeId: availability.roomTypeId,
            availableRooms: availability.availableRooms,
            soldRooms: availability.soldRooms,
            rate: availability.baseRate
        },
        ...additionalData
    });
};

auditLogSchema.statics.logChannelSync = async function(hotelId, channel, data, success = true, error = null) {
    return await this.logChange({
        hotelId,
        tableName: data.tableName || 'RoomAvailability',
        recordId: data.recordId,
        changeType: 'sync',
        source: 'channel_sync',
        sourceDetails: {
            channel: channel._id,
            channelName: channel.name
        },
        newValues: data.newValues || {},
        error: error ? {
            message: error.message,
            code: error.code,
            stack: error.stack
        } : undefined,
        metadata: {
            priority: success ? 'medium' : 'high',
            tags: ['channel_sync', channel.category]
        }
    });
};

auditLogSchema.statics.getChangeHistory = function(tableName, recordId, options = {}) {
    const query = {
        tableName,
        recordId
    };

    if (options.hotelId) {
        query.hotelId = options.hotelId;
    }

    if (options.userId) {
        query.userId = options.userId;
    }

    if (options.dateRange) {
        query.createdAt = {
            $gte: options.dateRange.start,
            $lte: options.dateRange.end
        };
    }

    return this.find(query)
        .populate('userId', 'name email')
        .populate('sourceDetails.channel', 'name category')
        .sort({
            createdAt: -1
        })
        .limit(options.limit || 100);
};

auditLogSchema.statics.logFormAction = async function(template, action, userId, additionalData = {}) {
    return await this.logChange({
        hotelId: template.hotelId,
        tableName: 'BookingFormTemplate',
        recordId: template._id,
        changeType: action,
        userId,
        formDetails: {
            templateName: template.name,
            templateCategory: template.category,
            fieldCount: template.fieldCount || template.fields ?.length || 0,
            status: template.status
        },
        ...additionalData
    });
};

auditLogSchema.statics.getUnreconciledChanges = function(hotelId, channel = null) {
    const query = {
        hotelId,
        'reconciliation.status': 'pending',
        source: 'channel_sync'
    };

    if (channel) {
        query['sourceDetails.channel'] = channel;
    }

    return this.find(query)
        .populate('sourceDetails.channel', 'name category')
        .sort({
            createdAt: 1
        });
};

auditLogSchema.statics.logSettingsChange = async function(settings, changeType, userId, additionalData = {}) {
    return await this.logChange({
        hotelId: settings.hotelId,
        tableName: 'WebSettings',
        recordId: settings._id,
        changeType,
        userId,
        source: additionalData.source || 'manual',
        oldValues: additionalData.backup ?.data || {},
        newValues: additionalData.changes || {},
        metadata: {
            section: additionalData.section,
            backup: additionalData.backup,
            priority: 'medium',
            tags: ['web_settings', changeType]
        },
        ...additionalData
    });
};

// Instance methods
auditLogSchema.methods.markReconciled = function(userId, notes) {
    this.reconciliation.status = 'reconciled';
    this.reconciliation.reconciledAt = new Date();
    this.reconciliation.reconciledBy = userId;
    if (notes) this.reconciliation.notes = notes;

    return this.save();
};

auditLogSchema.methods.markDiscrepancy = function(userId, notes) {
    this.reconciliation.status = 'discrepancy';
    this.reconciliation.reconciledAt = new Date();
    this.reconciliation.reconciledBy = userId;
    this.reconciliation.notes = notes;

    return this.save();
};

export default mongoose.model('AuditLog', auditLogSchema);