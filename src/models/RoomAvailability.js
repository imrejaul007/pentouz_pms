import mongoose from 'mongoose';

// This is the DATE-LEVEL INVENTORY model for channel management
const roomAvailabilitySchema = new mongoose.Schema({
  inventoryId: {
    type: String,
    required: false, // Will be generated by pre-save hook
    unique: true,
    sparse: true
  },
  hotelId: {
    type: mongoose.Schema.ObjectId,
    ref: 'Hotel',
    required: true
  },
  roomTypeId: {
    type: mongoose.Schema.ObjectId,
    ref: 'RoomType',
    required: true
  },
  date: {
    type: Date,
    required: true
  },
  // Core inventory data for OTA sync
  totalRooms: {
    type: Number,
    required: true,
    min: 0
  },
  availableRooms: {
    type: Number,
    required: true,
    min: 0
  },
  soldRooms: {
    type: Number,
    default: 0,
    min: 0
  },
  blockedRooms: {
    type: Number,
    default: 0,
    min: 0
  },
  overbookedRooms: {
    type: Number,
    default: 0,
    min: 0
  },
  // Status flags for channel management
  stopSellFlag: {
    type: Boolean,
    default: false
  },
  closedToArrival: {
    type: Boolean,
    default: false
  },
  closedToDeparture: {
    type: Boolean,
    default: false
  },
  // Restrictions
  minLengthOfStay: {
    type: Number,
    default: 1,
    min: 1
  },
  maxLengthOfStay: {
    type: Number,
    default: 30,
    min: 1
  },
  // Rate information (for quick access)
  baseRate: {
    type: Number,
    min: 0
  },
  sellingRate: {
    type: Number,
    min: 0
  },
  currency: {
    type: String,
    default: 'INR',
    uppercase: true
  },
  // Channel-specific overrides for OTA sync
  channelInventory: [{
    channel: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Channel'
    },
    channelId: String,
    availableRooms: {
      type: Number,
      min: 0
    },
    rate: {
      type: Number,
      min: 0
    },
    restrictions: {
      stopSell: { type: Boolean, default: false },
      closedToArrival: { type: Boolean, default: false },
      closedToDeparture: { type: Boolean, default: false },
      minLOS: { type: Number, default: 1 },
      maxLOS: { type: Number, default: 30 }
    },
    lastSyncedAt: Date,
    syncStatus: {
      type: String,
      enum: ['pending', 'success', 'failed'],
      default: 'pending'
    }
  }],
  // Reservation tracking for reconciliation
  reservations: [{
    bookingId: {
      type: mongoose.Schema.ObjectId,
      ref: 'Booking'
    },
    roomsReserved: {
      type: Number,
      min: 1
    },
    source: {
      type: String,
      enum: ['direct', 'booking_com', 'expedia', 'airbnb', 'agoda', 'other']
    },
    reservedAt: {
      type: Date,
      default: Date.now
    }
  }],
  // Sync tracking
  lastModifiedBy: {
    type: mongoose.Schema.ObjectId,
    ref: 'User'
  },
  lastSyncedAt: Date,
  needsSync: {
    type: Boolean,
    default: true
  },
  syncErrors: [{
    channel: String,
    error: String,
    timestamp: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Enhanced audit trail for comprehensive tracking
  inventoryChanges: [{
    timestamp: { type: Date, default: Date.now },
    action: {
      type: String,
      enum: ['booking', 'cancellation', 'modification', 'stop_sell', 'rate_change', 'inventory_adjustment', 'maintenance', 'cleaning']
    },
    userId: mongoose.Schema.ObjectId,
    source: String,
    oldValues: mongoose.Schema.Types.Mixed,
    newValues: mongoose.Schema.Types.Mixed,
    reason: String,
    metadata: {
      bookingId: mongoose.Schema.ObjectId,
      channel: String,
      ipAddress: String,
      userAgent: String
    }
  }],
  
  // Performance metrics tracking
  performanceMetrics: {
    lastUpdated: { type: Date, default: Date.now },
    averageOccupancy: { type: Number, default: 0 },
    revenuePerRoom: { type: Number, default: 0 },
    conversionRate: { type: Number, default: 0 },
    lastCalculated: { type: Date, default: Date.now }
  }
}, {
  timestamps: true
});

// Compound indexes for performance and uniqueness
roomAvailabilitySchema.index({ 
  hotelId: 1, 
  roomTypeId: 1, 
  date: 1 
}, { unique: true });

roomAvailabilitySchema.index({ hotelId: 1, date: 1 });
roomAvailabilitySchema.index({ roomTypeId: 1, date: 1 });
roomAvailabilitySchema.index({ date: 1, needsSync: 1 });
roomAvailabilitySchema.index({ 'channelInventory.channel': 1, date: 1 });

// Pre-save middleware to generate inventoryId and validate data
roomAvailabilitySchema.pre('save', function(next) {
  // Generate unique inventory ID
  if (!this.inventoryId) {
    const dateStr = this.date.toISOString().slice(0, 10).replace(/-/g, '');
    const roomTypeStr = this.roomTypeId.toString().slice(-6);
    this.inventoryId = `AVAIL_${dateStr}_${roomTypeStr}`;
  }
  
  // Validate inventory consistency
  const totalAllocated = this.soldRooms + this.blockedRooms;
  if (totalAllocated > this.totalRooms + this.overbookedRooms) {
    return next(new Error('Total allocated rooms exceed available inventory'));
  }
  
  // Update available rooms
  this.availableRooms = this.totalRooms - this.soldRooms - this.blockedRooms;
  
  // Mark as needing sync when inventory changes
  if (this.isModified('soldRooms') || this.isModified('availableRooms') || 
      this.isModified('stopSellFlag') || this.isModified('baseRate')) {
    this.needsSync = true;
  }
  
  next();
});

// Static methods for inventory management
roomAvailabilitySchema.statics.getInventoryForDateRange = async function(hotelId, roomTypeId, startDate, endDate) {
  return await this.find({
    hotelId,
    roomTypeId,
    date: {
      $gte: startDate,
      $lte: endDate
    }
  }).sort({ date: 1 });
};

roomAvailabilitySchema.statics.createInventoryForMonth = async function(hotelId, roomTypeId, year, month, totalRooms, baseRate) {
  const inventoryRecords = [];
  const daysInMonth = new Date(year, month, 0).getDate();
  
  for (let day = 1; day <= daysInMonth; day++) {
    const date = new Date(year, month - 1, day);
    inventoryRecords.push({
      hotelId,
      roomTypeId,
      date,
      totalRooms,
      availableRooms: totalRooms,
      soldRooms: 0,
      blockedRooms: 0,
      baseRate
    });
  }
  
  return await this.insertMany(inventoryRecords, { ordered: false });
};

// Instance methods
roomAvailabilitySchema.methods.bookRooms = function(roomsCount, bookingId, source = 'direct', userId = null, metadata = {}) {
  if (roomsCount > this.availableRooms) {
    throw new Error('Not enough rooms available');
  }
  
  // Store old values for audit
  const oldValues = {
    availableRooms: this.availableRooms,
    soldRooms: this.soldRooms
  };
  
  this.soldRooms += roomsCount;
  this.availableRooms -= roomsCount;
  
  this.reservations.push({
    bookingId,
    roomsReserved: roomsCount,
    source
  });
  
  // Add to audit trail
  this.inventoryChanges.push({
    action: 'booking',
    userId: userId,
    source: source,
    oldValues: oldValues,
    newValues: {
      availableRooms: this.availableRooms,
      soldRooms: this.soldRooms
    },
    reason: 'Room booking',
    metadata: {
      bookingId: bookingId,
      channel: source,
      ...metadata
    }
  });
  
  this.needsSync = true;
  return this.save();
};

// Method to update stop sell status with audit trail
roomAvailabilitySchema.methods.updateStopSellStatus = function(stopSell, userId = null, reason = '', metadata = {}) {
  const oldValues = {
    stopSellFlag: this.stopSellFlag,
    closedToArrival: this.closedToArrival,
    closedToDeparture: this.closedToDeparture
  };
  
  this.stopSellFlag = stopSell.stopSellFlag !== undefined ? stopSell.stopSellFlag : this.stopSellFlag;
  this.closedToArrival = stopSell.closedToArrival !== undefined ? stopSell.closedToArrival : this.closedToArrival;
  this.closedToDeparture = stopSell.closedToDeparture !== undefined ? stopSell.closedToDeparture : this.closedToDeparture;
  
  // Add to audit trail
  this.inventoryChanges.push({
    action: 'stop_sell',
    userId: userId,
    source: 'manual',
    oldValues: oldValues,
    newValues: {
      stopSellFlag: this.stopSellFlag,
      closedToArrival: this.closedToArrival,
      closedToDeparture: this.closedToDeparture
    },
    reason: reason || 'Stop sell status update',
    metadata: metadata
  });
  
  this.needsSync = true;
  return this.save();
};

// Method to update rates with audit trail
roomAvailabilitySchema.methods.updateRates = function(newRates, userId = null, reason = '', metadata = {}) {
  const oldValues = {
    baseRate: this.baseRate,
    sellingRate: this.sellingRate,
    currency: this.currency
  };
  
  if (newRates.baseRate !== undefined) this.baseRate = newRates.baseRate;
  if (newRates.sellingRate !== undefined) this.sellingRate = newRates.sellingRate;
  if (newRates.currency !== undefined) this.currency = newRates.currency;
  
  // Add to audit trail
  this.inventoryChanges.push({
    action: 'rate_change',
    userId: userId,
    source: 'manual',
    oldValues: oldValues,
    newValues: {
      baseRate: this.baseRate,
      sellingRate: this.sellingRate,
      currency: this.currency
    },
    reason: reason || 'Rate update',
    metadata: metadata
  });
  
  this.needsSync = true;
  return this.save();
};

// Static method with transaction-based locking for atomic operations
roomAvailabilitySchema.statics.bookRoomsWithLock = async function(
  hotelId, 
  roomTypeId, 
  checkIn, 
  checkOut, 
  roomsCount, 
  bookingId, 
  source = 'direct'
) {
  const session = await mongoose.startSession();
  
  try {
    let result = false;
    
    await session.withTransaction(async () => {
      // Get inventory for each date in the range
      const startDate = new Date(checkIn);
      const endDate = new Date(checkOut);
      
      for (let date = startDate; date < endDate; date.setDate(date.getDate() + 1)) {
        const currentDate = new Date(date);
        
        // Find and lock the inventory record
        const inventory = await this.findOne({
          hotelId,
          roomTypeId,
          date: currentDate
        }).session(session).select('+availableRooms +soldRooms +blockedRooms +totalRooms');
        
        if (!inventory) {
          throw new Error(`Inventory not found for date: ${currentDate.toISOString().split('T')[0]}`);
        }
        
        // Check availability with atomic update
        const updateResult = await this.updateOne(
          { 
            _id: inventory._id,
            availableRooms: { $gte: roomsCount }
          },
          {
            $inc: { 
              soldRooms: roomsCount,
              availableRooms: -roomsCount
            },
            $push: {
              reservations: {
                bookingId,
                roomsReserved: roomsCount,
                source,
                reservedAt: new Date()
              }
            },
            needsSync: true,
            lastModifiedAt: new Date()
          }
        ).session(session);
        
        if (updateResult.modifiedCount === 0) {
          throw new Error(`Not enough rooms available for date: ${currentDate.toISOString().split('T')[0]}`);
        }
      }
      
      result = true;
    });
    
    return result;
  } finally {
    await session.endSession();
  }
};

// Static method to release rooms with transaction locking
roomAvailabilitySchema.statics.releaseRoomsWithLock = async function(
  hotelId, 
  roomTypeId, 
  checkIn, 
  checkOut, 
  roomsCount, 
  bookingId
) {
  const session = await mongoose.startSession();
  
  try {
    let result = false;
    
    await session.withTransaction(async () => {
      const startDate = new Date(checkIn);
      const endDate = new Date(checkOut);
      
      for (let date = startDate; date < endDate; date.setDate(date.getDate() + 1)) {
        const currentDate = new Date(date);
        
        // Find and update the inventory record
        const inventory = await this.findOne({
          hotelId,
          roomTypeId,
          date: currentDate
        }).session(session);
        
        if (!inventory) {
          throw new Error(`Inventory not found for date: ${currentDate.toISOString().split('T')[0]}`);
        }
        
        // Remove the specific reservation
        const reservationIndex = inventory.reservations.findIndex(
          r => r.bookingId && r.bookingId.toString() === bookingId.toString()
        );
        
        if (reservationIndex === -1) {
          throw new Error(`Reservation not found for booking: ${bookingId}`);
        }
        
        const roomsToRelease = Math.min(roomsCount, inventory.reservations[reservationIndex].roomsReserved);
        
        // Atomic update to release rooms
        await this.updateOne(
          { _id: inventory._id },
          {
            $inc: { 
              soldRooms: -roomsToRelease,
              availableRooms: roomsToRelease
            },
            $pull: {
              reservations: {
                bookingId: bookingId
              }
            },
            needsSync: true,
            lastModifiedAt: new Date()
          }
        ).session(session);
      }
      
      result = true;
    });
    
    return result;
  } finally {
    await session.endSession();
  }
};

// Static method to check availability with locking
roomAvailabilitySchema.statics.checkAvailabilityWithLock = async function(
  hotelId, 
  roomTypeId, 
  checkIn, 
  checkOut, 
  roomsCount
) {
  const session = await mongoose.startSession();
  
  try {
    let availability = [];
    
    await session.withTransaction(async () => {
      const startDate = new Date(checkIn);
      const endDate = new Date(checkOut);
      
      for (let date = startDate; date < endDate; date.setDate(date.getDate() + 1)) {
        const currentDate = new Date(date);
        
        const inventory = await this.findOne({
          hotelId,
          roomTypeId,
          date: currentDate
        }).session(session).select('availableRooms stopSellFlag closedToArrival minLengthOfStay');
        
        if (!inventory) {
          throw new Error(`Inventory not found for date: ${currentDate.toISOString().split('T')[0]}`);
        }
        
        availability.push({
          date: currentDate,
          availableRooms: inventory.availableRooms,
          canBook: inventory.availableRooms >= roomsCount && 
                   !inventory.stopSellFlag && 
                   !inventory.closedToArrival,
          restrictions: {
            stopSell: inventory.stopSellFlag,
            closedToArrival: inventory.closedToArrival,
            minLengthOfStay: inventory.minLengthOfStay
          }
        });
      }
    });
    
    return availability;
  } finally {
    await session.endSession();
  }
};

roomAvailabilitySchema.methods.releaseRooms = function(roomsCount, bookingId) {
  const reservation = this.reservations.find(r => r.bookingId.equals(bookingId));
  
  if (!reservation) {
    throw new Error('Reservation not found');
  }
  
  if (roomsCount > reservation.roomsReserved) {
    throw new Error('Cannot release more rooms than reserved');
  }
  
  this.soldRooms -= roomsCount;
  this.availableRooms += roomsCount;
  
  if (roomsCount === reservation.roomsReserved) {
    this.reservations = this.reservations.filter(r => !r.bookingId.equals(bookingId));
  } else {
    reservation.roomsReserved -= roomsCount;
  }
  
  this.needsSync = true;
  return this.save();
};

// Method to get audit trail for a specific date range
roomAvailabilitySchema.statics.getAuditTrail = async function(hotelId, roomTypeId, startDate, endDate, action = null) {
  const query = {
    hotelId,
    roomTypeId,
    date: { $gte: startDate, $lte: endDate }
  };
  
  if (action) {
    query['inventoryChanges.action'] = action;
  }
  
  const records = await this.find(query)
    .select('date inventoryChanges')
    .sort({ date: 1 });
  
  const auditTrail = [];
  
  records.forEach(record => {
    record.inventoryChanges.forEach(change => {
      if (action && change.action !== action) return;
      
      auditTrail.push({
        date: record.date,
        action: change.action,
        timestamp: change.timestamp,
        userId: change.userId,
        source: change.source,
        oldValues: change.oldValues,
        newValues: change.newValues,
        reason: change.reason,
        metadata: change.metadata
      });
    });
  });
  
  return auditTrail.sort((a, b) => b.timestamp - a.timestamp);
};

// Method to get performance metrics
roomAvailabilitySchema.statics.getPerformanceMetrics = async function(hotelId, roomTypeId, startDate, endDate) {
  const records = await this.find({
    hotelId,
    roomTypeId,
    date: { $gte: startDate, $lte: endDate }
  }).sort({ date: 1 });
  
  if (records.length === 0) return null;
  
  const totalDays = records.length;
  let totalRevenue = 0;
  let totalOccupancy = 0;
  let totalBookings = 0;
  
  records.forEach(record => {
    totalRevenue += (record.sellingRate || record.baseRate || 0) * record.soldRooms;
    totalOccupancy += record.soldRooms;
    totalBookings += record.reservations.length;
  });
  
  const averageOccupancy = totalOccupancy / totalDays;
  const revenuePerRoom = totalRevenue / totalDays;
  const conversionRate = totalBookings / totalDays;
  
  return {
    period: { startDate, endDate },
    totalDays,
    totalRevenue,
    averageOccupancy: Math.round(averageOccupancy * 100) / 100,
    revenuePerRoom: Math.round(revenuePerRoom * 100) / 100,
    conversionRate: Math.round(conversionRate * 100) / 100,
    lastCalculated: new Date()
  };
};

export default mongoose.model('RoomAvailability', roomAvailabilitySchema);
